"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@paper-design";
exports.ids = ["vendor-chunks/@paper-design"];
exports.modules = {

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/color-props-are-equal.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/color-props-are-equal.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   colorPropsAreEqual: () => (/* binding */ colorPropsAreEqual)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nfunction colorPropsAreEqual(prevProps, nextProps) {\n  for (const key in prevProps) {\n    if (key === \"colors\") {\n      const prevIsArray = Array.isArray(prevProps.colors);\n      const nextIsArray = Array.isArray(nextProps.colors);\n      if (!prevIsArray || !nextIsArray) {\n        if (Object.is(prevProps.colors, nextProps.colors) === false) {\n          return false;\n        }\n        continue;\n      }\n      if (prevProps.colors?.length !== nextProps.colors?.length) {\n        return false;\n      }\n      if (!prevProps.colors?.every((color, index) => color === nextProps.colors?.[index])) {\n        return false;\n      }\n      continue;\n    }\n    if (Object.is(prevProps[key], nextProps[key]) === false) {\n      return false;\n    }\n  }\n  return true;\n}\n\n//# sourceMappingURL=color-props-are-equal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3QvY29sb3ItcHJvcHMtYXJlLWVxdWFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3QvY29sb3ItcHJvcHMtYXJlLWVxdWFsLmpzPzE1MjIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqICAgICAgICAgICAgICAgICAgICBQYXBlciBTaGFkZXJzICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcGFwZXItZGVzaWduL3NoYWRlcnMgICAgICAgKlxuICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cbmZ1bmN0aW9uIGNvbG9yUHJvcHNBcmVFcXVhbChwcmV2UHJvcHMsIG5leHRQcm9wcykge1xuICBmb3IgKGNvbnN0IGtleSBpbiBwcmV2UHJvcHMpIHtcbiAgICBpZiAoa2V5ID09PSBcImNvbG9yc1wiKSB7XG4gICAgICBjb25zdCBwcmV2SXNBcnJheSA9IEFycmF5LmlzQXJyYXkocHJldlByb3BzLmNvbG9ycyk7XG4gICAgICBjb25zdCBuZXh0SXNBcnJheSA9IEFycmF5LmlzQXJyYXkobmV4dFByb3BzLmNvbG9ycyk7XG4gICAgICBpZiAoIXByZXZJc0FycmF5IHx8ICFuZXh0SXNBcnJheSkge1xuICAgICAgICBpZiAoT2JqZWN0LmlzKHByZXZQcm9wcy5jb2xvcnMsIG5leHRQcm9wcy5jb2xvcnMpID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2UHJvcHMuY29sb3JzPy5sZW5ndGggIT09IG5leHRQcm9wcy5jb2xvcnM/Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXByZXZQcm9wcy5jb2xvcnM/LmV2ZXJ5KChjb2xvciwgaW5kZXgpID0+IGNvbG9yID09PSBuZXh0UHJvcHMuY29sb3JzPy5baW5kZXhdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5pcyhwcmV2UHJvcHNba2V5XSwgbmV4dFByb3BzW2tleV0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCB7XG4gIGNvbG9yUHJvcHNBcmVFcXVhbFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbG9yLXByb3BzLWFyZS1lcXVhbC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/color-props-are-equal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/shader-mount.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/shader-mount.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShaderMount: () => (/* binding */ ShaderMount)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-mount.js\");\n/* harmony import */ var _use_merge_refs_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./use-merge-refs.js */ \"(ssr)/./node_modules/@paper-design/shaders-react/dist/use-merge-refs.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/shared/react-jsx-runtime.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\"use client\";\n\n\n\n\nasync function processUniforms(uniformsProp) {\n  const processedUniforms = {};\n  const imageLoadPromises = [];\n  const isValidUrl = (url) => {\n    try {\n      if (url.startsWith(\"/\")) return true;\n      new URL(url);\n      return true;\n    } catch {\n      return false;\n    }\n  };\n  const isExternalUrl = (url) => {\n    try {\n      if (url.startsWith(\"/\")) return false;\n      const urlObject = new URL(url, window.location.origin);\n      return urlObject.origin !== window.location.origin;\n    } catch {\n      return false;\n    }\n  };\n  Object.entries(uniformsProp).forEach(([key, value]) => {\n    if (typeof value === \"string\") {\n      if (!isValidUrl(value)) {\n        console.warn(`Uniform \"${key}\" has invalid URL \"${value}\". Skipping image loading.`);\n        return;\n      }\n      const imagePromise = new Promise((resolve, reject) => {\n        const img = new Image();\n        if (isExternalUrl(value)) {\n          img.crossOrigin = \"anonymous\";\n        }\n        img.onload = () => {\n          processedUniforms[key] = img;\n          resolve();\n        };\n        img.onerror = () => {\n          console.error(`Could not set uniforms. Failed to load image at ${value}`);\n          reject();\n        };\n        img.src = value;\n      });\n      imageLoadPromises.push(imagePromise);\n    } else {\n      processedUniforms[key] = value;\n    }\n  });\n  await Promise.all(imageLoadPromises);\n  return processedUniforms;\n}\nconst ShaderMount = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(\n  function ShaderMountImpl({\n    fragmentShader,\n    uniforms: uniformsProp,\n    webGlContextAttributes,\n    speed = 0,\n    frame = 0,\n    minPixelRatio,\n    maxPixelCount,\n    ...divProps\n  }, forwardedRef) {\n    const [isInitialized, setIsInitialized] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const divRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const shaderMountRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      const initShader = async () => {\n        const uniforms = await processUniforms(uniformsProp);\n        if (divRef.current && !shaderMountRef.current) {\n          shaderMountRef.current = new _paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.ShaderMount(\n            divRef.current,\n            fragmentShader,\n            uniforms,\n            webGlContextAttributes,\n            speed,\n            frame,\n            minPixelRatio,\n            maxPixelCount\n          );\n          setIsInitialized(true);\n        }\n      };\n      initShader();\n      return () => {\n        shaderMountRef.current?.dispose();\n        shaderMountRef.current = null;\n      };\n    }, [fragmentShader, webGlContextAttributes]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      const updateUniforms = async () => {\n        const uniforms = await processUniforms(uniformsProp);\n        shaderMountRef.current?.setUniforms(uniforms);\n      };\n      updateUniforms();\n    }, [uniformsProp, isInitialized]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      shaderMountRef.current?.setSpeed(speed);\n    }, [speed, isInitialized]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      shaderMountRef.current?.setMaxPixelCount(maxPixelCount);\n    }, [maxPixelCount, isInitialized]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      shaderMountRef.current?.setMinPixelRatio(minPixelRatio);\n    }, [minPixelRatio, isInitialized]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      shaderMountRef.current?.setFrame(frame);\n    }, [frame, isInitialized]);\n    const mergedRef = (0,_use_merge_refs_js__WEBPACK_IMPORTED_MODULE_3__.useMergeRefs)([divRef, forwardedRef]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { ref: mergedRef, ...divProps });\n  }\n);\nShaderMount.displayName = \"ShaderMount\";\n\n//# sourceMappingURL=shader-mount.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3Qvc2hhZGVyLW1vdW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDZ0U7QUFHakM7QUFDb0I7QUFDWDtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLElBQUkscUJBQXFCLE1BQU07QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLE1BQU07QUFDakY7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlEQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCw4Q0FBOEMsK0NBQVE7QUFDdEQsbUJBQW1CLDZDQUFNO0FBQ3pCLDJCQUEyQiw2Q0FBTTtBQUNqQyxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDhEQUFrQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBLEtBQUs7QUFDTCxzQkFBc0IsZ0VBQVk7QUFDbEMsMkJBQTJCLHNEQUFHLFVBQVUsNkJBQTZCO0FBQ3JFO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3Qvc2hhZGVyLW1vdW50LmpzP2RlZDYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqICAgICAgICAgICAgICAgICAgICBQYXBlciBTaGFkZXJzICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcGFwZXItZGVzaWduL3NoYWRlcnMgICAgICAgKlxuICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cblwidXNlIGNsaWVudFwiO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIGZvcndhcmRSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge1xuICBTaGFkZXJNb3VudCBhcyBTaGFkZXJNb3VudFZhbmlsbGFcbn0gZnJvbSBcIkBwYXBlci1kZXNpZ24vc2hhZGVyc1wiO1xuaW1wb3J0IHsgdXNlTWVyZ2VSZWZzIH0gZnJvbSBcIi4vdXNlLW1lcmdlLXJlZnMuanNcIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1VuaWZvcm1zKHVuaWZvcm1zUHJvcCkge1xuICBjb25zdCBwcm9jZXNzZWRVbmlmb3JtcyA9IHt9O1xuICBjb25zdCBpbWFnZUxvYWRQcm9taXNlcyA9IFtdO1xuICBjb25zdCBpc1ZhbGlkVXJsID0gKHVybCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoXCIvXCIpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIG5ldyBVUkwodXJsKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgaXNFeHRlcm5hbFVybCA9ICh1cmwpID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHVybC5zdGFydHNXaXRoKFwiL1wiKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgY29uc3QgdXJsT2JqZWN0ID0gbmV3IFVSTCh1cmwsIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pO1xuICAgICAgcmV0dXJuIHVybE9iamVjdC5vcmlnaW4gIT09IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuICBPYmplY3QuZW50cmllcyh1bmlmb3Jtc1Byb3ApLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmICghaXNWYWxpZFVybCh2YWx1ZSkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBVbmlmb3JtIFwiJHtrZXl9XCIgaGFzIGludmFsaWQgVVJMIFwiJHt2YWx1ZX1cIi4gU2tpcHBpbmcgaW1hZ2UgbG9hZGluZy5gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaW1hZ2VQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaWYgKGlzRXh0ZXJuYWxVcmwodmFsdWUpKSB7XG4gICAgICAgICAgaW1nLmNyb3NzT3JpZ2luID0gXCJhbm9ueW1vdXNcIjtcbiAgICAgICAgfVxuICAgICAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgIHByb2Nlc3NlZFVuaWZvcm1zW2tleV0gPSBpbWc7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBpbWcub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBDb3VsZCBub3Qgc2V0IHVuaWZvcm1zLiBGYWlsZWQgdG8gbG9hZCBpbWFnZSBhdCAke3ZhbHVlfWApO1xuICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICB9O1xuICAgICAgICBpbWcuc3JjID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIGltYWdlTG9hZFByb21pc2VzLnB1c2goaW1hZ2VQcm9taXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzc2VkVW5pZm9ybXNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG4gIGF3YWl0IFByb21pc2UuYWxsKGltYWdlTG9hZFByb21pc2VzKTtcbiAgcmV0dXJuIHByb2Nlc3NlZFVuaWZvcm1zO1xufVxuY29uc3QgU2hhZGVyTW91bnQgPSBmb3J3YXJkUmVmKFxuICBmdW5jdGlvbiBTaGFkZXJNb3VudEltcGwoe1xuICAgIGZyYWdtZW50U2hhZGVyLFxuICAgIHVuaWZvcm1zOiB1bmlmb3Jtc1Byb3AsXG4gICAgd2ViR2xDb250ZXh0QXR0cmlidXRlcyxcbiAgICBzcGVlZCA9IDAsXG4gICAgZnJhbWUgPSAwLFxuICAgIG1pblBpeGVsUmF0aW8sXG4gICAgbWF4UGl4ZWxDb3VudCxcbiAgICAuLi5kaXZQcm9wc1xuICB9LCBmb3J3YXJkZWRSZWYpIHtcbiAgICBjb25zdCBbaXNJbml0aWFsaXplZCwgc2V0SXNJbml0aWFsaXplZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgZGl2UmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHNoYWRlck1vdW50UmVmID0gdXNlUmVmKG51bGwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBpbml0U2hhZGVyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB1bmlmb3JtcyA9IGF3YWl0IHByb2Nlc3NVbmlmb3Jtcyh1bmlmb3Jtc1Byb3ApO1xuICAgICAgICBpZiAoZGl2UmVmLmN1cnJlbnQgJiYgIXNoYWRlck1vdW50UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBzaGFkZXJNb3VudFJlZi5jdXJyZW50ID0gbmV3IFNoYWRlck1vdW50VmFuaWxsYShcbiAgICAgICAgICAgIGRpdlJlZi5jdXJyZW50LFxuICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXIsXG4gICAgICAgICAgICB1bmlmb3JtcyxcbiAgICAgICAgICAgIHdlYkdsQ29udGV4dEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBzcGVlZCxcbiAgICAgICAgICAgIGZyYW1lLFxuICAgICAgICAgICAgbWluUGl4ZWxSYXRpbyxcbiAgICAgICAgICAgIG1heFBpeGVsQ291bnRcbiAgICAgICAgICApO1xuICAgICAgICAgIHNldElzSW5pdGlhbGl6ZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpbml0U2hhZGVyKCk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBzaGFkZXJNb3VudFJlZi5jdXJyZW50Py5kaXNwb3NlKCk7XG4gICAgICAgIHNoYWRlck1vdW50UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfTtcbiAgICB9LCBbZnJhZ21lbnRTaGFkZXIsIHdlYkdsQ29udGV4dEF0dHJpYnV0ZXNdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlVW5pZm9ybXMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHVuaWZvcm1zID0gYXdhaXQgcHJvY2Vzc1VuaWZvcm1zKHVuaWZvcm1zUHJvcCk7XG4gICAgICAgIHNoYWRlck1vdW50UmVmLmN1cnJlbnQ/LnNldFVuaWZvcm1zKHVuaWZvcm1zKTtcbiAgICAgIH07XG4gICAgICB1cGRhdGVVbmlmb3JtcygpO1xuICAgIH0sIFt1bmlmb3Jtc1Byb3AsIGlzSW5pdGlhbGl6ZWRdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgc2hhZGVyTW91bnRSZWYuY3VycmVudD8uc2V0U3BlZWQoc3BlZWQpO1xuICAgIH0sIFtzcGVlZCwgaXNJbml0aWFsaXplZF0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBzaGFkZXJNb3VudFJlZi5jdXJyZW50Py5zZXRNYXhQaXhlbENvdW50KG1heFBpeGVsQ291bnQpO1xuICAgIH0sIFttYXhQaXhlbENvdW50LCBpc0luaXRpYWxpemVkXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIHNoYWRlck1vdW50UmVmLmN1cnJlbnQ/LnNldE1pblBpeGVsUmF0aW8obWluUGl4ZWxSYXRpbyk7XG4gICAgfSwgW21pblBpeGVsUmF0aW8sIGlzSW5pdGlhbGl6ZWRdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgc2hhZGVyTW91bnRSZWYuY3VycmVudD8uc2V0RnJhbWUoZnJhbWUpO1xuICAgIH0sIFtmcmFtZSwgaXNJbml0aWFsaXplZF0pO1xuICAgIGNvbnN0IG1lcmdlZFJlZiA9IHVzZU1lcmdlUmVmcyhbZGl2UmVmLCBmb3J3YXJkZWRSZWZdKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcImRpdlwiLCB7IHJlZjogbWVyZ2VkUmVmLCAuLi5kaXZQcm9wcyB9KTtcbiAgfVxuKTtcblNoYWRlck1vdW50LmRpc3BsYXlOYW1lID0gXCJTaGFkZXJNb3VudFwiO1xuZXhwb3J0IHtcbiAgU2hhZGVyTW91bnRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFkZXItbW91bnQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/shader-mount.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/shaders/mesh-gradient.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/shaders/mesh-gradient.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MeshGradient: () => (/* binding */ MeshGradient),\n/* harmony export */   beachPreset: () => (/* binding */ beachPreset),\n/* harmony export */   defaultPreset: () => (/* binding */ defaultPreset),\n/* harmony export */   inkPreset: () => (/* binding */ inkPreset),\n/* harmony export */   meshGradientPresets: () => (/* binding */ meshGradientPresets),\n/* harmony export */   purplePreset: () => (/* binding */ purplePreset)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _shader_mount_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shader-mount.js */ \"(ssr)/./node_modules/@paper-design/shaders-react/dist/shader-mount.js\");\n/* harmony import */ var _color_props_are_equal_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../color-props-are-equal.js */ \"(ssr)/./node_modules/@paper-design/shaders-react/dist/color-props-are-equal.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shaders/mesh-gradient.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/shared/react-jsx-runtime.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\n\n\n\n\nconst defaultPreset = {\n  name: \"Default\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    colors: [\"#e0eaff\", \"#241d9a\", \"#f75092\", \"#9f50d3\"],\n    distortion: 0.8,\n    swirl: 0.1\n  }\n};\nconst purplePreset = {\n  name: \"Purple\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultObjectSizing,\n    speed: 0.6,\n    frame: 0,\n    colors: [\"#aaa7d7\", \"#3c2b8e\"],\n    distortion: 1,\n    swirl: 1\n  }\n};\nconst beachPreset = {\n  name: \"Beach\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultObjectSizing,\n    speed: 0.1,\n    frame: 0,\n    colors: [\"#bcecf6\", \"#00aaff\", \"#00f7ff\", \"#ffd447\"],\n    distortion: 0.8,\n    swirl: 0.35\n  }\n};\nconst inkPreset = {\n  name: \"Ink\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    colors: [\"#ffffff\", \"#000000\"],\n    distortion: 1,\n    swirl: 0.2,\n    rotation: 90\n  }\n};\nconst meshGradientPresets = [defaultPreset, inkPreset, purplePreset, beachPreset];\nconst MeshGradient = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(function MeshGradientImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colors = defaultPreset.params.colors,\n  distortion = defaultPreset.params.distortion,\n  swirl = defaultPreset.params.swirl,\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  rotation = defaultPreset.params.rotation,\n  scale = defaultPreset.params.scale,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}) {\n  const uniforms = {\n    // Own uniforms\n    u_colors: colors.map(_paper_design_shaders__WEBPACK_IMPORTED_MODULE_3__.getShaderColorFromString),\n    u_colorsCount: colors.length,\n    u_distortion: distortion,\n    u_swirl: swirl,\n    // Sizing uniforms\n    u_fit: _paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.ShaderFitOptions[fit],\n    u_rotation: rotation,\n    u_scale: scale,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight\n  };\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    _shader_mount_js__WEBPACK_IMPORTED_MODULE_4__.ShaderMount,\n    {\n      ...props,\n      speed,\n      frame,\n      fragmentShader: _paper_design_shaders__WEBPACK_IMPORTED_MODULE_5__.meshGradientFragmentShader,\n      uniforms\n    }\n  );\n}, _color_props_are_equal_js__WEBPACK_IMPORTED_MODULE_6__.colorPropsAreEqual);\n\n//# sourceMappingURL=mesh-gradient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3Qvc2hhZGVycy9tZXNoLWdyYWRpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkI7QUFDb0I7QUFDZ0I7QUFNbEM7QUFDUztBQUN4QztBQUNBO0FBQ0E7QUFDQSxPQUFPLHNFQUFtQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sc0VBQW1CO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxzRUFBbUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHNFQUFtQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkNBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EseUJBQXlCLDJFQUF3QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUVBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzREFBRztBQUM1QixJQUFJLHlEQUFXO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkVBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRSx5RUFBa0I7QUFRbkI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9AcGFwZXItZGVzaWduL3NoYWRlcnMtcmVhY3QvZGlzdC9zaGFkZXJzL21lc2gtZ3JhZGllbnQuanM/YmY3MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogICAgICAgICAgICAgICAgICAgIFBhcGVyIFNoYWRlcnMgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXBlci1kZXNpZ24vc2hhZGVycyAgICAgICAqXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cblxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgU2hhZGVyTW91bnQgfSBmcm9tIFwiLi4vc2hhZGVyLW1vdW50LmpzXCI7XG5pbXBvcnQgeyBjb2xvclByb3BzQXJlRXF1YWwgfSBmcm9tIFwiLi4vY29sb3ItcHJvcHMtYXJlLWVxdWFsLmpzXCI7XG5pbXBvcnQge1xuICBkZWZhdWx0T2JqZWN0U2l6aW5nLFxuICBnZXRTaGFkZXJDb2xvckZyb21TdHJpbmcsXG4gIG1lc2hHcmFkaWVudEZyYWdtZW50U2hhZGVyLFxuICBTaGFkZXJGaXRPcHRpb25zXG59IGZyb20gXCJAcGFwZXItZGVzaWduL3NoYWRlcnNcIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuY29uc3QgZGVmYXVsdFByZXNldCA9IHtcbiAgbmFtZTogXCJEZWZhdWx0XCIsXG4gIHBhcmFtczoge1xuICAgIC4uLmRlZmF1bHRPYmplY3RTaXppbmcsXG4gICAgc3BlZWQ6IDEsXG4gICAgZnJhbWU6IDAsXG4gICAgY29sb3JzOiBbXCIjZTBlYWZmXCIsIFwiIzI0MWQ5YVwiLCBcIiNmNzUwOTJcIiwgXCIjOWY1MGQzXCJdLFxuICAgIGRpc3RvcnRpb246IDAuOCxcbiAgICBzd2lybDogMC4xXG4gIH1cbn07XG5jb25zdCBwdXJwbGVQcmVzZXQgPSB7XG4gIG5hbWU6IFwiUHVycGxlXCIsXG4gIHBhcmFtczoge1xuICAgIC4uLmRlZmF1bHRPYmplY3RTaXppbmcsXG4gICAgc3BlZWQ6IDAuNixcbiAgICBmcmFtZTogMCxcbiAgICBjb2xvcnM6IFtcIiNhYWE3ZDdcIiwgXCIjM2MyYjhlXCJdLFxuICAgIGRpc3RvcnRpb246IDEsXG4gICAgc3dpcmw6IDFcbiAgfVxufTtcbmNvbnN0IGJlYWNoUHJlc2V0ID0ge1xuICBuYW1lOiBcIkJlYWNoXCIsXG4gIHBhcmFtczoge1xuICAgIC4uLmRlZmF1bHRPYmplY3RTaXppbmcsXG4gICAgc3BlZWQ6IDAuMSxcbiAgICBmcmFtZTogMCxcbiAgICBjb2xvcnM6IFtcIiNiY2VjZjZcIiwgXCIjMDBhYWZmXCIsIFwiIzAwZjdmZlwiLCBcIiNmZmQ0NDdcIl0sXG4gICAgZGlzdG9ydGlvbjogMC44LFxuICAgIHN3aXJsOiAwLjM1XG4gIH1cbn07XG5jb25zdCBpbmtQcmVzZXQgPSB7XG4gIG5hbWU6IFwiSW5rXCIsXG4gIHBhcmFtczoge1xuICAgIC4uLmRlZmF1bHRPYmplY3RTaXppbmcsXG4gICAgc3BlZWQ6IDEsXG4gICAgZnJhbWU6IDAsXG4gICAgY29sb3JzOiBbXCIjZmZmZmZmXCIsIFwiIzAwMDAwMFwiXSxcbiAgICBkaXN0b3J0aW9uOiAxLFxuICAgIHN3aXJsOiAwLjIsXG4gICAgcm90YXRpb246IDkwXG4gIH1cbn07XG5jb25zdCBtZXNoR3JhZGllbnRQcmVzZXRzID0gW2RlZmF1bHRQcmVzZXQsIGlua1ByZXNldCwgcHVycGxlUHJlc2V0LCBiZWFjaFByZXNldF07XG5jb25zdCBNZXNoR3JhZGllbnQgPSBtZW1vKGZ1bmN0aW9uIE1lc2hHcmFkaWVudEltcGwoe1xuICAvLyBPd24gcHJvcHNcbiAgc3BlZWQgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5zcGVlZCxcbiAgZnJhbWUgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5mcmFtZSxcbiAgY29sb3JzID0gZGVmYXVsdFByZXNldC5wYXJhbXMuY29sb3JzLFxuICBkaXN0b3J0aW9uID0gZGVmYXVsdFByZXNldC5wYXJhbXMuZGlzdG9ydGlvbixcbiAgc3dpcmwgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5zd2lybCxcbiAgLy8gU2l6aW5nIHByb3BzXG4gIGZpdCA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLmZpdCxcbiAgcm90YXRpb24gPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5yb3RhdGlvbixcbiAgc2NhbGUgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5zY2FsZSxcbiAgb3JpZ2luWCA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLm9yaWdpblgsXG4gIG9yaWdpblkgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5vcmlnaW5ZLFxuICBvZmZzZXRYID0gZGVmYXVsdFByZXNldC5wYXJhbXMub2Zmc2V0WCxcbiAgb2Zmc2V0WSA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLm9mZnNldFksXG4gIHdvcmxkV2lkdGggPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy53b3JsZFdpZHRoLFxuICB3b3JsZEhlaWdodCA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLndvcmxkSGVpZ2h0LFxuICAuLi5wcm9wc1xufSkge1xuICBjb25zdCB1bmlmb3JtcyA9IHtcbiAgICAvLyBPd24gdW5pZm9ybXNcbiAgICB1X2NvbG9yczogY29sb3JzLm1hcChnZXRTaGFkZXJDb2xvckZyb21TdHJpbmcpLFxuICAgIHVfY29sb3JzQ291bnQ6IGNvbG9ycy5sZW5ndGgsXG4gICAgdV9kaXN0b3J0aW9uOiBkaXN0b3J0aW9uLFxuICAgIHVfc3dpcmw6IHN3aXJsLFxuICAgIC8vIFNpemluZyB1bmlmb3Jtc1xuICAgIHVfZml0OiBTaGFkZXJGaXRPcHRpb25zW2ZpdF0sXG4gICAgdV9yb3RhdGlvbjogcm90YXRpb24sXG4gICAgdV9zY2FsZTogc2NhbGUsXG4gICAgdV9vZmZzZXRYOiBvZmZzZXRYLFxuICAgIHVfb2Zmc2V0WTogb2Zmc2V0WSxcbiAgICB1X29yaWdpblg6IG9yaWdpblgsXG4gICAgdV9vcmlnaW5ZOiBvcmlnaW5ZLFxuICAgIHVfd29ybGRXaWR0aDogd29ybGRXaWR0aCxcbiAgICB1X3dvcmxkSGVpZ2h0OiB3b3JsZEhlaWdodFxuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICBTaGFkZXJNb3VudCxcbiAgICB7XG4gICAgICAuLi5wcm9wcyxcbiAgICAgIHNwZWVkLFxuICAgICAgZnJhbWUsXG4gICAgICBmcmFnbWVudFNoYWRlcjogbWVzaEdyYWRpZW50RnJhZ21lbnRTaGFkZXIsXG4gICAgICB1bmlmb3Jtc1xuICAgIH1cbiAgKTtcbn0sIGNvbG9yUHJvcHNBcmVFcXVhbCk7XG5leHBvcnQge1xuICBNZXNoR3JhZGllbnQsXG4gIGJlYWNoUHJlc2V0LFxuICBkZWZhdWx0UHJlc2V0LFxuICBpbmtQcmVzZXQsXG4gIG1lc2hHcmFkaWVudFByZXNldHMsXG4gIHB1cnBsZVByZXNldFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc2gtZ3JhZGllbnQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/shaders/mesh-gradient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/use-merge-refs.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/use-merge-refs.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMergeRefs: () => (/* binding */ useMergeRefs)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\nfunction useMergeRefs(refs) {\n  const cleanupRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n  const refEffect = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((instance) => {\n    const cleanups = refs.map((ref) => {\n      if (ref == null) {\n        return;\n      }\n      if (typeof ref === \"function\") {\n        const refCallback = ref;\n        const refCleanup = refCallback(instance);\n        return typeof refCleanup === \"function\" ? refCleanup : () => {\n          refCallback(null);\n        };\n      }\n      ref.current = instance;\n      return () => {\n        ref.current = null;\n      };\n    });\n    return () => {\n      cleanups.forEach((refCleanup) => refCleanup?.());\n    };\n  }, refs);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (refs.every((ref) => ref == null)) {\n      return null;\n    }\n    return (value) => {\n      if (cleanupRef.current) {\n        cleanupRef.current();\n        cleanupRef.current = void 0;\n      }\n      if (value != null) {\n        cleanupRef.current = refEffect(value);\n      }\n    };\n  }, refs);\n}\n\n//# sourceMappingURL=use-merge-refs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3QvdXNlLW1lcmdlLXJlZnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0I7QUFDL0I7QUFDQSxxQkFBcUIseUNBQVk7QUFDakMsb0JBQW9CLDhDQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFNBQVMsMENBQWE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9AcGFwZXItZGVzaWduL3NoYWRlcnMtcmVhY3QvZGlzdC91c2UtbWVyZ2UtcmVmcy5qcz8yYTAyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgICAgICAgICAgICAgICAgUGFwZXIgU2hhZGVycyAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3BhcGVyLWRlc2lnbi9zaGFkZXJzICAgICAgICpcbiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZU1lcmdlUmVmcyhyZWZzKSB7XG4gIGNvbnN0IGNsZWFudXBSZWYgPSBSZWFjdC51c2VSZWYodm9pZCAwKTtcbiAgY29uc3QgcmVmRWZmZWN0ID0gUmVhY3QudXNlQ2FsbGJhY2soKGluc3RhbmNlKSA9PiB7XG4gICAgY29uc3QgY2xlYW51cHMgPSByZWZzLm1hcCgocmVmKSA9PiB7XG4gICAgICBpZiAocmVmID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiByZWYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCByZWZDYWxsYmFjayA9IHJlZjtcbiAgICAgICAgY29uc3QgcmVmQ2xlYW51cCA9IHJlZkNhbGxiYWNrKGluc3RhbmNlKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiByZWZDbGVhbnVwID09PSBcImZ1bmN0aW9uXCIgPyByZWZDbGVhbnVwIDogKCkgPT4ge1xuICAgICAgICAgIHJlZkNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmVmLmN1cnJlbnQgPSBpbnN0YW5jZTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFudXBzLmZvckVhY2goKHJlZkNsZWFudXApID0+IHJlZkNsZWFudXA/LigpKTtcbiAgICB9O1xuICB9LCByZWZzKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChyZWZzLmV2ZXJ5KChyZWYpID0+IHJlZiA9PSBudWxsKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgIGlmIChjbGVhbnVwUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2xlYW51cFJlZi5jdXJyZW50KCk7XG4gICAgICAgIGNsZWFudXBSZWYuY3VycmVudCA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGNsZWFudXBSZWYuY3VycmVudCA9IHJlZkVmZmVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgcmVmcyk7XG59XG5leHBvcnQge1xuICB1c2VNZXJnZVJlZnNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtbWVyZ2UtcmVmcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/use-merge-refs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   getShaderColorFromString: () => (/* binding */ getShaderColorFromString)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nfunction getShaderColorFromString(colorString) {\n  if (Array.isArray(colorString)) {\n    if (colorString.length === 4) return colorString;\n    if (colorString.length === 3) return [...colorString, 1];\n    return fallbackColor;\n  }\n  if (typeof colorString !== \"string\") {\n    return fallbackColor;\n  }\n  let r, g, b, a = 1;\n  if (colorString.startsWith(\"#\")) {\n    [r, g, b, a] = hexToRgba(colorString);\n  } else if (colorString.startsWith(\"rgb\")) {\n    [r, g, b, a] = parseRgba(colorString);\n  } else if (colorString.startsWith(\"hsl\")) {\n    [r, g, b, a] = hslaToRgba(parseHsla(colorString));\n  } else {\n    console.error(\"Unsupported color format\", colorString);\n    return fallbackColor;\n  }\n  return [clamp(r, 0, 1), clamp(g, 0, 1), clamp(b, 0, 1), clamp(a, 0, 1)];\n}\nfunction hexToRgba(hex) {\n  hex = hex.replace(/^#/, \"\");\n  if (hex.length === 3) {\n    hex = hex.split(\"\").map((char) => char + char).join(\"\");\n  }\n  if (hex.length === 6) {\n    hex = hex + \"ff\";\n  }\n  const r = parseInt(hex.slice(0, 2), 16) / 255;\n  const g = parseInt(hex.slice(2, 4), 16) / 255;\n  const b = parseInt(hex.slice(4, 6), 16) / 255;\n  const a = parseInt(hex.slice(6, 8), 16) / 255;\n  return [r, g, b, a];\n}\nfunction parseRgba(rgba) {\n  const match = rgba.match(/^rgba?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*([0-9.]+))?\\s*\\)$/i);\n  if (!match) return [0, 0, 0, 1];\n  return [\n    parseInt(match[1] ?? \"0\") / 255,\n    parseInt(match[2] ?? \"0\") / 255,\n    parseInt(match[3] ?? \"0\") / 255,\n    match[4] === void 0 ? 1 : parseFloat(match[4])\n  ];\n}\nfunction parseHsla(hsla) {\n  const match = hsla.match(/^hsla?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*(?:,\\s*([0-9.]+))?\\s*\\)$/i);\n  if (!match) return [0, 0, 0, 1];\n  return [\n    parseInt(match[1] ?? \"0\"),\n    parseInt(match[2] ?? \"0\"),\n    parseInt(match[3] ?? \"0\"),\n    match[4] === void 0 ? 1 : parseFloat(match[4])\n  ];\n}\nfunction hslaToRgba(hsla) {\n  const [h, s, l, a] = hsla;\n  const hDecimal = h / 360;\n  const sDecimal = s / 100;\n  const lDecimal = l / 100;\n  let r, g, b;\n  if (s === 0) {\n    r = g = b = lDecimal;\n  } else {\n    const hue2rgb = (p2, q2, t) => {\n      if (t < 0) t += 1;\n      if (t > 1) t -= 1;\n      if (t < 1 / 6) return p2 + (q2 - p2) * 6 * t;\n      if (t < 1 / 2) return q2;\n      if (t < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;\n      return p2;\n    };\n    const q = lDecimal < 0.5 ? lDecimal * (1 + sDecimal) : lDecimal + sDecimal - lDecimal * sDecimal;\n    const p = 2 * lDecimal - q;\n    r = hue2rgb(p, q, hDecimal + 1 / 3);\n    g = hue2rgb(p, q, hDecimal);\n    b = hue2rgb(p, q, hDecimal - 1 / 3);\n  }\n  return [r, g, b, a];\n}\nconst clamp = (n, min, max) => Math.min(Math.max(n, min), max);\nconst fallbackColor = [0, 0, 0, 1];\n\n//# sourceMappingURL=get-shader-color-from-string.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvZ2V0LXNoYWRlci1jb2xvci1mcm9tLXN0cmluZy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvZ2V0LXNoYWRlci1jb2xvci1mcm9tLXN0cmluZy5qcz8yNTA5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgICAgICAgICAgICAgICAgUGFwZXIgU2hhZGVycyAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3BhcGVyLWRlc2lnbi9zaGFkZXJzICAgICAgICpcbiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG5mdW5jdGlvbiBnZXRTaGFkZXJDb2xvckZyb21TdHJpbmcoY29sb3JTdHJpbmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY29sb3JTdHJpbmcpKSB7XG4gICAgaWYgKGNvbG9yU3RyaW5nLmxlbmd0aCA9PT0gNCkgcmV0dXJuIGNvbG9yU3RyaW5nO1xuICAgIGlmIChjb2xvclN0cmluZy5sZW5ndGggPT09IDMpIHJldHVybiBbLi4uY29sb3JTdHJpbmcsIDFdO1xuICAgIHJldHVybiBmYWxsYmFja0NvbG9yO1xuICB9XG4gIGlmICh0eXBlb2YgY29sb3JTdHJpbmcgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZmFsbGJhY2tDb2xvcjtcbiAgfVxuICBsZXQgciwgZywgYiwgYSA9IDE7XG4gIGlmIChjb2xvclN0cmluZy5zdGFydHNXaXRoKFwiI1wiKSkge1xuICAgIFtyLCBnLCBiLCBhXSA9IGhleFRvUmdiYShjb2xvclN0cmluZyk7XG4gIH0gZWxzZSBpZiAoY29sb3JTdHJpbmcuc3RhcnRzV2l0aChcInJnYlwiKSkge1xuICAgIFtyLCBnLCBiLCBhXSA9IHBhcnNlUmdiYShjb2xvclN0cmluZyk7XG4gIH0gZWxzZSBpZiAoY29sb3JTdHJpbmcuc3RhcnRzV2l0aChcImhzbFwiKSkge1xuICAgIFtyLCBnLCBiLCBhXSA9IGhzbGFUb1JnYmEocGFyc2VIc2xhKGNvbG9yU3RyaW5nKSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5lcnJvcihcIlVuc3VwcG9ydGVkIGNvbG9yIGZvcm1hdFwiLCBjb2xvclN0cmluZyk7XG4gICAgcmV0dXJuIGZhbGxiYWNrQ29sb3I7XG4gIH1cbiAgcmV0dXJuIFtjbGFtcChyLCAwLCAxKSwgY2xhbXAoZywgMCwgMSksIGNsYW1wKGIsIDAsIDEpLCBjbGFtcChhLCAwLCAxKV07XG59XG5mdW5jdGlvbiBoZXhUb1JnYmEoaGV4KSB7XG4gIGhleCA9IGhleC5yZXBsYWNlKC9eIy8sIFwiXCIpO1xuICBpZiAoaGV4Lmxlbmd0aCA9PT0gMykge1xuICAgIGhleCA9IGhleC5zcGxpdChcIlwiKS5tYXAoKGNoYXIpID0+IGNoYXIgKyBjaGFyKS5qb2luKFwiXCIpO1xuICB9XG4gIGlmIChoZXgubGVuZ3RoID09PSA2KSB7XG4gICAgaGV4ID0gaGV4ICsgXCJmZlwiO1xuICB9XG4gIGNvbnN0IHIgPSBwYXJzZUludChoZXguc2xpY2UoMCwgMiksIDE2KSAvIDI1NTtcbiAgY29uc3QgZyA9IHBhcnNlSW50KGhleC5zbGljZSgyLCA0KSwgMTYpIC8gMjU1O1xuICBjb25zdCBiID0gcGFyc2VJbnQoaGV4LnNsaWNlKDQsIDYpLCAxNikgLyAyNTU7XG4gIGNvbnN0IGEgPSBwYXJzZUludChoZXguc2xpY2UoNiwgOCksIDE2KSAvIDI1NTtcbiAgcmV0dXJuIFtyLCBnLCBiLCBhXTtcbn1cbmZ1bmN0aW9uIHBhcnNlUmdiYShyZ2JhKSB7XG4gIGNvbnN0IG1hdGNoID0gcmdiYS5tYXRjaCgvXnJnYmE/XFxzKlxcKFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqKD86LFxccyooWzAtOS5dKykpP1xccypcXCkkL2kpO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gWzAsIDAsIDAsIDFdO1xuICByZXR1cm4gW1xuICAgIHBhcnNlSW50KG1hdGNoWzFdID8/IFwiMFwiKSAvIDI1NSxcbiAgICBwYXJzZUludChtYXRjaFsyXSA/PyBcIjBcIikgLyAyNTUsXG4gICAgcGFyc2VJbnQobWF0Y2hbM10gPz8gXCIwXCIpIC8gMjU1LFxuICAgIG1hdGNoWzRdID09PSB2b2lkIDAgPyAxIDogcGFyc2VGbG9hdChtYXRjaFs0XSlcbiAgXTtcbn1cbmZ1bmN0aW9uIHBhcnNlSHNsYShoc2xhKSB7XG4gIGNvbnN0IG1hdGNoID0gaHNsYS5tYXRjaCgvXmhzbGE/XFxzKlxcKFxccyooXFxkKylcXHMqLFxccyooXFxkKyklXFxzKixcXHMqKFxcZCspJVxccyooPzosXFxzKihbMC05Ll0rKSk/XFxzKlxcKSQvaSk7XG4gIGlmICghbWF0Y2gpIHJldHVybiBbMCwgMCwgMCwgMV07XG4gIHJldHVybiBbXG4gICAgcGFyc2VJbnQobWF0Y2hbMV0gPz8gXCIwXCIpLFxuICAgIHBhcnNlSW50KG1hdGNoWzJdID8/IFwiMFwiKSxcbiAgICBwYXJzZUludChtYXRjaFszXSA/PyBcIjBcIiksXG4gICAgbWF0Y2hbNF0gPT09IHZvaWQgMCA/IDEgOiBwYXJzZUZsb2F0KG1hdGNoWzRdKVxuICBdO1xufVxuZnVuY3Rpb24gaHNsYVRvUmdiYShoc2xhKSB7XG4gIGNvbnN0IFtoLCBzLCBsLCBhXSA9IGhzbGE7XG4gIGNvbnN0IGhEZWNpbWFsID0gaCAvIDM2MDtcbiAgY29uc3Qgc0RlY2ltYWwgPSBzIC8gMTAwO1xuICBjb25zdCBsRGVjaW1hbCA9IGwgLyAxMDA7XG4gIGxldCByLCBnLCBiO1xuICBpZiAocyA9PT0gMCkge1xuICAgIHIgPSBnID0gYiA9IGxEZWNpbWFsO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGh1ZTJyZ2IgPSAocDIsIHEyLCB0KSA9PiB7XG4gICAgICBpZiAodCA8IDApIHQgKz0gMTtcbiAgICAgIGlmICh0ID4gMSkgdCAtPSAxO1xuICAgICAgaWYgKHQgPCAxIC8gNikgcmV0dXJuIHAyICsgKHEyIC0gcDIpICogNiAqIHQ7XG4gICAgICBpZiAodCA8IDEgLyAyKSByZXR1cm4gcTI7XG4gICAgICBpZiAodCA8IDIgLyAzKSByZXR1cm4gcDIgKyAocTIgLSBwMikgKiAoMiAvIDMgLSB0KSAqIDY7XG4gICAgICByZXR1cm4gcDI7XG4gICAgfTtcbiAgICBjb25zdCBxID0gbERlY2ltYWwgPCAwLjUgPyBsRGVjaW1hbCAqICgxICsgc0RlY2ltYWwpIDogbERlY2ltYWwgKyBzRGVjaW1hbCAtIGxEZWNpbWFsICogc0RlY2ltYWw7XG4gICAgY29uc3QgcCA9IDIgKiBsRGVjaW1hbCAtIHE7XG4gICAgciA9IGh1ZTJyZ2IocCwgcSwgaERlY2ltYWwgKyAxIC8gMyk7XG4gICAgZyA9IGh1ZTJyZ2IocCwgcSwgaERlY2ltYWwpO1xuICAgIGIgPSBodWUycmdiKHAsIHEsIGhEZWNpbWFsIC0gMSAvIDMpO1xuICB9XG4gIHJldHVybiBbciwgZywgYiwgYV07XG59XG5jb25zdCBjbGFtcCA9IChuLCBtaW4sIG1heCkgPT4gTWF0aC5taW4oTWF0aC5tYXgobiwgbWluKSwgbWF4KTtcbmNvbnN0IGZhbGxiYWNrQ29sb3IgPSBbMCwgMCwgMCwgMV07XG5leHBvcnQge1xuICBjbGFtcCxcbiAgZ2V0U2hhZGVyQ29sb3JGcm9tU3RyaW5nXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LXNoYWRlci1jb2xvci1mcm9tLXN0cmluZy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/shader-mount.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/shader-mount.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShaderMount: () => (/* binding */ ShaderMount),\n/* harmony export */   isPaperShaderElement: () => (/* binding */ isPaperShaderElement)\n/* harmony export */ });\n/* harmony import */ var _vertex_shader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vertex-shader.js */ \"(ssr)/./node_modules/@paper-design/shaders/dist/vertex-shader.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\nconst DEFAULT_MAX_PIXEL_COUNT = 1920 * 1080 * 4;\nclass ShaderMount {\n  parentElement;\n  canvasElement;\n  gl;\n  program = null;\n  uniformLocations = {};\n  /** The fragment shader that we are using */\n  fragmentShader;\n  /** Stores the RAF for the render loop */\n  rafId = null;\n  /** Time of the last rendered frame */\n  lastRenderTime = 0;\n  /** Total time that we have played any animation, passed as a uniform to the shader for time-based VFX */\n  currentFrame = 0;\n  /** The current speed that we progress through animation time (multiplies by delta time every update). Allows negatives to play in reverse. If set to 0, rAF will stop entirely so static shaders have no recurring performance costs */\n  speed = 0;\n  /** Uniforms that are provided by the user for the specific shader being mounted (not including uniforms that this Mount adds, like time and resolution) */\n  providedUniforms;\n  /** Just a sanity check to make sure frames don't run after we're disposed */\n  hasBeenDisposed = false;\n  /** If the resolution of the canvas has changed since the last render */\n  resolutionChanged = true;\n  /** Store textures that are provided by the user */\n  textures = /* @__PURE__ */ new Map();\n  minPixelRatio;\n  maxPixelCount;\n  isSafari = isSafari();\n  uniformCache = {};\n  textureUnitMap = /* @__PURE__ */ new Map();\n  constructor(parentElement, fragmentShader, uniforms, webGlContextAttributes, speed = 0, frame = 0, minPixelRatio = 2, maxPixelCount = DEFAULT_MAX_PIXEL_COUNT) {\n    if (parentElement instanceof HTMLElement) {\n      this.parentElement = parentElement;\n    } else {\n      throw new Error(\"Paper Shaders: parent element must be an HTMLElement\");\n    }\n    if (!document.querySelector(\"style[data-paper-shader]\")) {\n      const styleElement = document.createElement(\"style\");\n      styleElement.innerHTML = defaultStyle;\n      styleElement.setAttribute(\"data-paper-shader\", \"\");\n      document.head.prepend(styleElement);\n    }\n    const canvasElement = document.createElement(\"canvas\");\n    this.canvasElement = canvasElement;\n    this.parentElement.prepend(canvasElement);\n    this.fragmentShader = fragmentShader;\n    this.providedUniforms = uniforms;\n    this.currentFrame = frame;\n    this.minPixelRatio = minPixelRatio;\n    this.maxPixelCount = maxPixelCount;\n    const gl = canvasElement.getContext(\"webgl2\", webGlContextAttributes);\n    if (!gl) {\n      throw new Error(\"Paper Shaders: WebGL is not supported in this browser\");\n    }\n    this.gl = gl;\n    this.initProgram();\n    this.setupPositionAttribute();\n    this.setupUniforms();\n    this.setUniformValues(this.providedUniforms);\n    this.setupResizeObserver();\n    this.setSpeed(speed);\n    this.parentElement.setAttribute(\"data-paper-shader\", \"\");\n    this.parentElement.paperShaderMount = this;\n  }\n  initProgram = () => {\n    const program = createProgram(this.gl, _vertex_shader_js__WEBPACK_IMPORTED_MODULE_0__.vertexShaderSource, this.fragmentShader);\n    if (!program) return;\n    this.program = program;\n  };\n  setupPositionAttribute = () => {\n    const positionAttributeLocation = this.gl.getAttribLocation(this.program, \"a_position\");\n    const positionBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);\n    const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);\n    this.gl.enableVertexAttribArray(positionAttributeLocation);\n    this.gl.vertexAttribPointer(positionAttributeLocation, 2, this.gl.FLOAT, false, 0, 0);\n  };\n  setupUniforms = () => {\n    const uniformLocations = {\n      u_time: this.gl.getUniformLocation(this.program, \"u_time\"),\n      u_pixelRatio: this.gl.getUniformLocation(this.program, \"u_pixelRatio\"),\n      u_resolution: this.gl.getUniformLocation(this.program, \"u_resolution\")\n    };\n    Object.entries(this.providedUniforms).forEach(([key, value]) => {\n      uniformLocations[key] = this.gl.getUniformLocation(this.program, key);\n      if (value instanceof HTMLImageElement) {\n        const aspectRatioUniformName = `${key}AspectRatio`;\n        uniformLocations[aspectRatioUniformName] = this.gl.getUniformLocation(this.program, aspectRatioUniformName);\n      }\n    });\n    this.uniformLocations = uniformLocations;\n  };\n  /**\n   * The scale that we should render at.\n   * - Used to target 2x rendering even on 1x screens for better antialiasing\n   * - Prevents the virtual resolution from going beyond the maximum resolution\n   * - Accounts for the page zoom level so we render in physical device pixels rather than CSS pixels\n   */\n  renderScale = 1;\n  parentWidth = 0;\n  parentHeight = 0;\n  resizeObserver = null;\n  setupResizeObserver = () => {\n    this.resizeObserver = new ResizeObserver(([entry]) => {\n      if (entry?.borderBoxSize[0]) {\n        this.parentWidth = entry.borderBoxSize[0].inlineSize;\n        this.parentHeight = entry.borderBoxSize[0].blockSize;\n      }\n      this.handleResize();\n    });\n    this.resizeObserver.observe(this.parentElement);\n    visualViewport?.addEventListener(\"resize\", this.handleVisualViewportChange);\n    const rect = this.parentElement.getBoundingClientRect();\n    this.parentWidth = rect.width;\n    this.parentHeight = rect.height;\n    this.handleResize();\n  };\n  // Visual viewport resize handler, mainly used to react to browser zoom changes.\n  // Wait 2 frames to align with when the resize observer callback is done (in case it might follow):\n  // - Frame 1: a paint after the visual viewport resize\n  // - Frame 2: a paint after the resize observer has been handled, if it was ever triggered\n  //\n  // Both resize observer and visual viewport will react to classic browser zoom changes,\n  // so we dedupe the callbacks, but pinch zoom only triggers the visual viewport handler.\n  resizeRafId = null;\n  handleVisualViewportChange = () => {\n    if (this.resizeRafId !== null) {\n      cancelAnimationFrame(this.resizeRafId);\n    }\n    this.resizeRafId = requestAnimationFrame(() => {\n      this.resizeRafId = requestAnimationFrame(() => {\n        this.handleResize();\n      });\n    });\n  };\n  /** Resize handler for when the container div changes size or the max pixel count changes and we want to resize our canvas to match */\n  handleResize = () => {\n    if (this.resizeRafId !== null) {\n      cancelAnimationFrame(this.resizeRafId);\n    }\n    const pinchZoom = visualViewport?.scale ?? 1;\n    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n    const innerWidth = visualViewport ? visualViewport.scale * visualViewport.width + scrollbarWidth : window.innerWidth;\n    const classicZoom = Math.round(1e4 * window.outerWidth / innerWidth) / 1e4;\n    const realPixelRatio = this.isSafari ? devicePixelRatio : devicePixelRatio / classicZoom;\n    const targetPixelRatio = Math.max(realPixelRatio, this.minPixelRatio);\n    const targetRenderScale = targetPixelRatio * classicZoom * pinchZoom;\n    const targetPixelWidth = this.parentWidth * targetRenderScale;\n    const targetPixelHeight = this.parentHeight * targetRenderScale;\n    const maxPixelCountHeadroom = Math.sqrt(this.maxPixelCount) / Math.sqrt(targetPixelWidth * targetPixelHeight);\n    const newRenderScale = targetRenderScale * Math.min(1, maxPixelCountHeadroom);\n    const newWidth = Math.round(this.parentWidth * newRenderScale);\n    const newHeight = Math.round(this.parentHeight * newRenderScale);\n    if (this.canvasElement.width !== newWidth || this.canvasElement.height !== newHeight || this.renderScale !== newRenderScale) {\n      this.renderScale = newRenderScale;\n      this.canvasElement.width = newWidth;\n      this.canvasElement.height = newHeight;\n      this.resolutionChanged = true;\n      this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);\n      this.render(performance.now());\n    }\n  };\n  render = (currentTime) => {\n    if (this.hasBeenDisposed) return;\n    if (this.program === null) {\n      console.warn(\"Tried to render before program or gl was initialized\");\n      return;\n    }\n    const dt = currentTime - this.lastRenderTime;\n    this.lastRenderTime = currentTime;\n    if (this.speed !== 0) {\n      this.currentFrame += dt * this.speed;\n    }\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n    this.gl.useProgram(this.program);\n    this.gl.uniform1f(this.uniformLocations.u_time, this.currentFrame * 1e-3);\n    if (this.resolutionChanged) {\n      this.gl.uniform2f(this.uniformLocations.u_resolution, this.gl.canvas.width, this.gl.canvas.height);\n      this.gl.uniform1f(this.uniformLocations.u_pixelRatio, this.renderScale);\n      this.resolutionChanged = false;\n    }\n    this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);\n    if (this.speed !== 0) {\n      this.requestRender();\n    } else {\n      this.rafId = null;\n    }\n  };\n  requestRender = () => {\n    if (this.rafId !== null) {\n      cancelAnimationFrame(this.rafId);\n    }\n    this.rafId = requestAnimationFrame(this.render);\n  };\n  /** Creates a texture from an image and sets it into a uniform value */\n  setTextureUniform = (uniformName, image) => {\n    if (!image.complete || image.naturalWidth === 0) {\n      throw new Error(`Paper Shaders: image for uniform ${uniformName} must be fully loaded`);\n    }\n    const existingTexture = this.textures.get(uniformName);\n    if (existingTexture) {\n      this.gl.deleteTexture(existingTexture);\n    }\n    if (!this.textureUnitMap.has(uniformName)) {\n      this.textureUnitMap.set(uniformName, this.textureUnitMap.size);\n    }\n    const textureUnit = this.textureUnitMap.get(uniformName);\n    this.gl.activeTexture(this.gl.TEXTURE0 + textureUnit);\n    const texture = this.gl.createTexture();\n    this.gl.bindTexture(this.gl.TEXTURE_2D, texture);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\n    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);\n    const error = this.gl.getError();\n    if (error !== this.gl.NO_ERROR || texture === null) {\n      console.error(\"Paper Shaders: WebGL error when uploading texture:\", error);\n      return;\n    }\n    this.textures.set(uniformName, texture);\n    const location = this.uniformLocations[uniformName];\n    if (location) {\n      this.gl.uniform1i(location, textureUnit);\n      const aspectRatioUniformName = `${uniformName}AspectRatio`;\n      const aspectRatioLocation = this.uniformLocations[aspectRatioUniformName];\n      if (aspectRatioLocation) {\n        const aspectRatio = image.naturalWidth / image.naturalHeight;\n        this.gl.uniform1f(aspectRatioLocation, aspectRatio);\n      }\n    }\n  };\n  /** Utility: recursive equality test for all the uniforms */\n  areUniformValuesEqual = (a, b) => {\n    if (a === b) return true;\n    if (Array.isArray(a) && Array.isArray(b) && a.length === b.length) {\n      return a.every((val, i) => this.areUniformValuesEqual(val, b[i]));\n    }\n    return false;\n  };\n  /** Sets the provided uniform values into the WebGL program, can be a partial list of uniforms that have changed */\n  setUniformValues = (updatedUniforms) => {\n    this.gl.useProgram(this.program);\n    Object.entries(updatedUniforms).forEach(([key, value]) => {\n      let cacheValue = value;\n      if (value instanceof HTMLImageElement) {\n        cacheValue = `${value.src.slice(0, 200)}|${value.naturalWidth}x${value.naturalHeight}`;\n      }\n      if (this.areUniformValuesEqual(this.uniformCache[key], cacheValue)) return;\n      this.uniformCache[key] = cacheValue;\n      const location = this.uniformLocations[key];\n      if (!location) {\n        console.warn(`Uniform location for ${key} not found`);\n        return;\n      }\n      if (value instanceof HTMLImageElement) {\n        this.setTextureUniform(key, value);\n      } else if (Array.isArray(value)) {\n        let flatArray = null;\n        let valueLength = null;\n        if (value[0] !== void 0 && Array.isArray(value[0])) {\n          const firstChildLength = value[0].length;\n          if (value.every((arr) => arr.length === firstChildLength)) {\n            flatArray = value.flat();\n            valueLength = firstChildLength;\n          } else {\n            console.warn(`All child arrays must be the same length for ${key}`);\n            return;\n          }\n        } else {\n          flatArray = value;\n          valueLength = flatArray.length;\n        }\n        switch (valueLength) {\n          case 2:\n            this.gl.uniform2fv(location, flatArray);\n            break;\n          case 3:\n            this.gl.uniform3fv(location, flatArray);\n            break;\n          case 4:\n            this.gl.uniform4fv(location, flatArray);\n            break;\n          case 9:\n            this.gl.uniformMatrix3fv(location, false, flatArray);\n            break;\n          case 16:\n            this.gl.uniformMatrix4fv(location, false, flatArray);\n            break;\n          default:\n            console.warn(`Unsupported uniform array length: ${valueLength}`);\n        }\n      } else if (typeof value === \"number\") {\n        this.gl.uniform1f(location, value);\n      } else if (typeof value === \"boolean\") {\n        this.gl.uniform1i(location, value ? 1 : 0);\n      } else {\n        console.warn(`Unsupported uniform type for ${key}: ${typeof value}`);\n      }\n    });\n  };\n  /** Gets the current total animation time from 0ms */\n  getCurrentFrame = () => {\n    return this.currentFrame;\n  };\n  /** Set a frame to get a deterministic result, frames are literally just milliseconds from zero since the animation started */\n  setFrame = (newFrame) => {\n    this.currentFrame = newFrame;\n    this.lastRenderTime = performance.now();\n    this.render(performance.now());\n  };\n  /** Set an animation speed (or 0 to stop animation) */\n  setSpeed = (newSpeed = 1) => {\n    this.speed = newSpeed;\n    if (this.rafId === null && newSpeed !== 0) {\n      this.lastRenderTime = performance.now();\n      this.rafId = requestAnimationFrame(this.render);\n    }\n    if (this.rafId !== null && newSpeed === 0) {\n      cancelAnimationFrame(this.rafId);\n      this.rafId = null;\n    }\n  };\n  /** Set the maximum pixel count for the shader, this will limit the number of pixels that will be rendered */\n  setMaxPixelCount = (newMaxPixelCount = DEFAULT_MAX_PIXEL_COUNT) => {\n    this.maxPixelCount = newMaxPixelCount;\n    this.handleResize();\n  };\n  /** Set the minimum pixel ratio for the shader */\n  setMinPixelRatio = (newMinPixelRatio = 2) => {\n    this.minPixelRatio = newMinPixelRatio;\n    this.handleResize();\n  };\n  /** Update the uniforms that are provided by the outside shader, can be a partial set with only the uniforms that have changed */\n  setUniforms = (newUniforms) => {\n    this.setUniformValues(newUniforms);\n    this.providedUniforms = { ...this.providedUniforms, ...newUniforms };\n    this.render(performance.now());\n  };\n  /** Dispose of the shader mount, cleaning up all of the WebGL resources */\n  dispose = () => {\n    this.hasBeenDisposed = true;\n    if (this.rafId !== null) {\n      cancelAnimationFrame(this.rafId);\n      this.rafId = null;\n    }\n    if (this.gl && this.program) {\n      this.textures.forEach((texture) => {\n        this.gl.deleteTexture(texture);\n      });\n      this.textures.clear();\n      this.gl.deleteProgram(this.program);\n      this.program = null;\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n      this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);\n      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n      this.gl.getError();\n    }\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n      this.resizeObserver = null;\n    }\n    visualViewport?.removeEventListener(\"resize\", this.handleVisualViewportChange);\n    this.uniformLocations = {};\n    this.parentElement.paperShaderMount = void 0;\n  };\n}\nfunction createShader(gl, type, source) {\n  const shader = gl.createShader(type);\n  if (!shader) return null;\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    console.error(\"An error occurred compiling the shaders: \" + gl.getShaderInfoLog(shader));\n    gl.deleteShader(shader);\n    return null;\n  }\n  return shader;\n}\nfunction createProgram(gl, vertexShaderSource2, fragmentShaderSource) {\n  const format = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);\n  const precision = format ? format.precision : null;\n  if (precision && precision < 23) {\n    vertexShaderSource2 = vertexShaderSource2.replace(/precision\\s+(lowp|mediump)\\s+float;/g, \"precision highp float;\");\n    fragmentShaderSource = fragmentShaderSource.replace(/precision\\s+(lowp|mediump)\\s+float/g, \"precision highp float\").replace(/\\b(uniform|varying|attribute)\\s+(lowp|mediump)\\s+(\\w+)/g, \"$1 highp $3\");\n  }\n  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource2);\n  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n  if (!vertexShader || !fragmentShader) return null;\n  const program = gl.createProgram();\n  if (!program) return null;\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.error(\"Unable to initialize the shader program: \" + gl.getProgramInfoLog(program));\n    gl.deleteProgram(program);\n    gl.deleteShader(vertexShader);\n    gl.deleteShader(fragmentShader);\n    return null;\n  }\n  gl.detachShader(program, vertexShader);\n  gl.detachShader(program, fragmentShader);\n  gl.deleteShader(vertexShader);\n  gl.deleteShader(fragmentShader);\n  return program;\n}\nconst defaultStyle = `@layer paper-shaders {\n  :where([data-paper-shader]) {\n    isolation: isolate;\n    position: relative;\n\n    & canvas {\n      contain: strict;\n      display: block;\n      position: absolute;\n      inset: 0;\n      z-index: -1;\n      width: 100%;\n      height: 100%;\n      border-radius: inherit;\n    }\n  }\n}`;\nfunction isPaperShaderElement(element) {\n  return \"paperShaderMount\" in element;\n}\nfunction isSafari() {\n  const ua = navigator.userAgent.toLowerCase();\n  return ua.includes(\"safari\") && !ua.includes(\"chrome\") && !ua.includes(\"android\");\n}\n\n//# sourceMappingURL=shader-mount.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLW1vdW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUV3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaUVBQWtCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxJQUFJO0FBQzlDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGFBQWE7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0IsR0FBRyxtQkFBbUIsR0FBRyxvQkFBb0I7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLHlFQUF5RSxJQUFJO0FBQzdFO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxZQUFZO0FBQzFFO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLHFEQUFxRCxJQUFJLElBQUksYUFBYTtBQUMxRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLDJCQUEyQjtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLW1vdW50LmpzPzVlYzkiXSwic291cmNlc0NvbnRlbnQiOlsiLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqICAgICAgICAgICAgICAgICAgICBQYXBlciBTaGFkZXJzICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcGFwZXItZGVzaWduL3NoYWRlcnMgICAgICAgKlxuICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cbmltcG9ydCB7IHZlcnRleFNoYWRlclNvdXJjZSB9IGZyb20gXCIuL3ZlcnRleC1zaGFkZXIuanNcIjtcbmNvbnN0IERFRkFVTFRfTUFYX1BJWEVMX0NPVU5UID0gMTkyMCAqIDEwODAgKiA0O1xuY2xhc3MgU2hhZGVyTW91bnQge1xuICBwYXJlbnRFbGVtZW50O1xuICBjYW52YXNFbGVtZW50O1xuICBnbDtcbiAgcHJvZ3JhbSA9IG51bGw7XG4gIHVuaWZvcm1Mb2NhdGlvbnMgPSB7fTtcbiAgLyoqIFRoZSBmcmFnbWVudCBzaGFkZXIgdGhhdCB3ZSBhcmUgdXNpbmcgKi9cbiAgZnJhZ21lbnRTaGFkZXI7XG4gIC8qKiBTdG9yZXMgdGhlIFJBRiBmb3IgdGhlIHJlbmRlciBsb29wICovXG4gIHJhZklkID0gbnVsbDtcbiAgLyoqIFRpbWUgb2YgdGhlIGxhc3QgcmVuZGVyZWQgZnJhbWUgKi9cbiAgbGFzdFJlbmRlclRpbWUgPSAwO1xuICAvKiogVG90YWwgdGltZSB0aGF0IHdlIGhhdmUgcGxheWVkIGFueSBhbmltYXRpb24sIHBhc3NlZCBhcyBhIHVuaWZvcm0gdG8gdGhlIHNoYWRlciBmb3IgdGltZS1iYXNlZCBWRlggKi9cbiAgY3VycmVudEZyYW1lID0gMDtcbiAgLyoqIFRoZSBjdXJyZW50IHNwZWVkIHRoYXQgd2UgcHJvZ3Jlc3MgdGhyb3VnaCBhbmltYXRpb24gdGltZSAobXVsdGlwbGllcyBieSBkZWx0YSB0aW1lIGV2ZXJ5IHVwZGF0ZSkuIEFsbG93cyBuZWdhdGl2ZXMgdG8gcGxheSBpbiByZXZlcnNlLiBJZiBzZXQgdG8gMCwgckFGIHdpbGwgc3RvcCBlbnRpcmVseSBzbyBzdGF0aWMgc2hhZGVycyBoYXZlIG5vIHJlY3VycmluZyBwZXJmb3JtYW5jZSBjb3N0cyAqL1xuICBzcGVlZCA9IDA7XG4gIC8qKiBVbmlmb3JtcyB0aGF0IGFyZSBwcm92aWRlZCBieSB0aGUgdXNlciBmb3IgdGhlIHNwZWNpZmljIHNoYWRlciBiZWluZyBtb3VudGVkIChub3QgaW5jbHVkaW5nIHVuaWZvcm1zIHRoYXQgdGhpcyBNb3VudCBhZGRzLCBsaWtlIHRpbWUgYW5kIHJlc29sdXRpb24pICovXG4gIHByb3ZpZGVkVW5pZm9ybXM7XG4gIC8qKiBKdXN0IGEgc2FuaXR5IGNoZWNrIHRvIG1ha2Ugc3VyZSBmcmFtZXMgZG9uJ3QgcnVuIGFmdGVyIHdlJ3JlIGRpc3Bvc2VkICovXG4gIGhhc0JlZW5EaXNwb3NlZCA9IGZhbHNlO1xuICAvKiogSWYgdGhlIHJlc29sdXRpb24gb2YgdGhlIGNhbnZhcyBoYXMgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCByZW5kZXIgKi9cbiAgcmVzb2x1dGlvbkNoYW5nZWQgPSB0cnVlO1xuICAvKiogU3RvcmUgdGV4dHVyZXMgdGhhdCBhcmUgcHJvdmlkZWQgYnkgdGhlIHVzZXIgKi9cbiAgdGV4dHVyZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBtaW5QaXhlbFJhdGlvO1xuICBtYXhQaXhlbENvdW50O1xuICBpc1NhZmFyaSA9IGlzU2FmYXJpKCk7XG4gIHVuaWZvcm1DYWNoZSA9IHt9O1xuICB0ZXh0dXJlVW5pdE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0cnVjdG9yKHBhcmVudEVsZW1lbnQsIGZyYWdtZW50U2hhZGVyLCB1bmlmb3Jtcywgd2ViR2xDb250ZXh0QXR0cmlidXRlcywgc3BlZWQgPSAwLCBmcmFtZSA9IDAsIG1pblBpeGVsUmF0aW8gPSAyLCBtYXhQaXhlbENvdW50ID0gREVGQVVMVF9NQVhfUElYRUxfQ09VTlQpIHtcbiAgICBpZiAocGFyZW50RWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICB0aGlzLnBhcmVudEVsZW1lbnQgPSBwYXJlbnRFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXBlciBTaGFkZXJzOiBwYXJlbnQgZWxlbWVudCBtdXN0IGJlIGFuIEhUTUxFbGVtZW50XCIpO1xuICAgIH1cbiAgICBpZiAoIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJzdHlsZVtkYXRhLXBhcGVyLXNoYWRlcl1cIikpIHtcbiAgICAgIGNvbnN0IHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgIHN0eWxlRWxlbWVudC5pbm5lckhUTUwgPSBkZWZhdWx0U3R5bGU7XG4gICAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1wYXBlci1zaGFkZXJcIiwgXCJcIik7XG4gICAgICBkb2N1bWVudC5oZWFkLnByZXBlbmQoc3R5bGVFbGVtZW50KTtcbiAgICB9XG4gICAgY29uc3QgY2FudmFzRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgdGhpcy5jYW52YXNFbGVtZW50ID0gY2FudmFzRWxlbWVudDtcbiAgICB0aGlzLnBhcmVudEVsZW1lbnQucHJlcGVuZChjYW52YXNFbGVtZW50KTtcbiAgICB0aGlzLmZyYWdtZW50U2hhZGVyID0gZnJhZ21lbnRTaGFkZXI7XG4gICAgdGhpcy5wcm92aWRlZFVuaWZvcm1zID0gdW5pZm9ybXM7XG4gICAgdGhpcy5jdXJyZW50RnJhbWUgPSBmcmFtZTtcbiAgICB0aGlzLm1pblBpeGVsUmF0aW8gPSBtaW5QaXhlbFJhdGlvO1xuICAgIHRoaXMubWF4UGl4ZWxDb3VudCA9IG1heFBpeGVsQ291bnQ7XG4gICAgY29uc3QgZ2wgPSBjYW52YXNFbGVtZW50LmdldENvbnRleHQoXCJ3ZWJnbDJcIiwgd2ViR2xDb250ZXh0QXR0cmlidXRlcyk7XG4gICAgaWYgKCFnbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFwZXIgU2hhZGVyczogV2ViR0wgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcIik7XG4gICAgfVxuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLmluaXRQcm9ncmFtKCk7XG4gICAgdGhpcy5zZXR1cFBvc2l0aW9uQXR0cmlidXRlKCk7XG4gICAgdGhpcy5zZXR1cFVuaWZvcm1zKCk7XG4gICAgdGhpcy5zZXRVbmlmb3JtVmFsdWVzKHRoaXMucHJvdmlkZWRVbmlmb3Jtcyk7XG4gICAgdGhpcy5zZXR1cFJlc2l6ZU9ic2VydmVyKCk7XG4gICAgdGhpcy5zZXRTcGVlZChzcGVlZCk7XG4gICAgdGhpcy5wYXJlbnRFbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtcGFwZXItc2hhZGVyXCIsIFwiXCIpO1xuICAgIHRoaXMucGFyZW50RWxlbWVudC5wYXBlclNoYWRlck1vdW50ID0gdGhpcztcbiAgfVxuICBpbml0UHJvZ3JhbSA9ICgpID0+IHtcbiAgICBjb25zdCBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSh0aGlzLmdsLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UsIHRoaXMuZnJhZ21lbnRTaGFkZXIpO1xuICAgIGlmICghcHJvZ3JhbSkgcmV0dXJuO1xuICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG4gIH07XG4gIHNldHVwUG9zaXRpb25BdHRyaWJ1dGUgPSAoKSA9PiB7XG4gICAgY29uc3QgcG9zaXRpb25BdHRyaWJ1dGVMb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcImFfcG9zaXRpb25cIik7XG4gICAgY29uc3QgcG9zaXRpb25CdWZmZXIgPSB0aGlzLmdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgcG9zaXRpb25CdWZmZXIpO1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IFstMSwgLTEsIDEsIC0xLCAtMSwgMSwgLTEsIDEsIDEsIC0xLCAxLCAxXTtcbiAgICB0aGlzLmdsLmJ1ZmZlckRhdGEodGhpcy5nbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25zKSwgdGhpcy5nbC5TVEFUSUNfRFJBVyk7XG4gICAgdGhpcy5nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkF0dHJpYnV0ZUxvY2F0aW9uKTtcbiAgICB0aGlzLmdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb25BdHRyaWJ1dGVMb2NhdGlvbiwgMiwgdGhpcy5nbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICB9O1xuICBzZXR1cFVuaWZvcm1zID0gKCkgPT4ge1xuICAgIGNvbnN0IHVuaWZvcm1Mb2NhdGlvbnMgPSB7XG4gICAgICB1X3RpbWU6IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgXCJ1X3RpbWVcIiksXG4gICAgICB1X3BpeGVsUmF0aW86IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgXCJ1X3BpeGVsUmF0aW9cIiksXG4gICAgICB1X3Jlc29sdXRpb246IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgXCJ1X3Jlc29sdXRpb25cIilcbiAgICB9O1xuICAgIE9iamVjdC5lbnRyaWVzKHRoaXMucHJvdmlkZWRVbmlmb3JtcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICB1bmlmb3JtTG9jYXRpb25zW2tleV0gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIGtleSk7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IGFzcGVjdFJhdGlvVW5pZm9ybU5hbWUgPSBgJHtrZXl9QXNwZWN0UmF0aW9gO1xuICAgICAgICB1bmlmb3JtTG9jYXRpb25zW2FzcGVjdFJhdGlvVW5pZm9ybU5hbWVdID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBhc3BlY3RSYXRpb1VuaWZvcm1OYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnVuaWZvcm1Mb2NhdGlvbnMgPSB1bmlmb3JtTG9jYXRpb25zO1xuICB9O1xuICAvKipcbiAgICogVGhlIHNjYWxlIHRoYXQgd2Ugc2hvdWxkIHJlbmRlciBhdC5cbiAgICogLSBVc2VkIHRvIHRhcmdldCAyeCByZW5kZXJpbmcgZXZlbiBvbiAxeCBzY3JlZW5zIGZvciBiZXR0ZXIgYW50aWFsaWFzaW5nXG4gICAqIC0gUHJldmVudHMgdGhlIHZpcnR1YWwgcmVzb2x1dGlvbiBmcm9tIGdvaW5nIGJleW9uZCB0aGUgbWF4aW11bSByZXNvbHV0aW9uXG4gICAqIC0gQWNjb3VudHMgZm9yIHRoZSBwYWdlIHpvb20gbGV2ZWwgc28gd2UgcmVuZGVyIGluIHBoeXNpY2FsIGRldmljZSBwaXhlbHMgcmF0aGVyIHRoYW4gQ1NTIHBpeGVsc1xuICAgKi9cbiAgcmVuZGVyU2NhbGUgPSAxO1xuICBwYXJlbnRXaWR0aCA9IDA7XG4gIHBhcmVudEhlaWdodCA9IDA7XG4gIHJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgc2V0dXBSZXNpemVPYnNlcnZlciA9ICgpID0+IHtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChbZW50cnldKSA9PiB7XG4gICAgICBpZiAoZW50cnk/LmJvcmRlckJveFNpemVbMF0pIHtcbiAgICAgICAgdGhpcy5wYXJlbnRXaWR0aCA9IGVudHJ5LmJvcmRlckJveFNpemVbMF0uaW5saW5lU2l6ZTtcbiAgICAgICAgdGhpcy5wYXJlbnRIZWlnaHQgPSBlbnRyeS5ib3JkZXJCb3hTaXplWzBdLmJsb2NrU2l6ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGFuZGxlUmVzaXplKCk7XG4gICAgfSk7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMucGFyZW50RWxlbWVudCk7XG4gICAgdmlzdWFsVmlld3BvcnQ/LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5oYW5kbGVWaXN1YWxWaWV3cG9ydENoYW5nZSk7XG4gICAgY29uc3QgcmVjdCA9IHRoaXMucGFyZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB0aGlzLnBhcmVudFdpZHRoID0gcmVjdC53aWR0aDtcbiAgICB0aGlzLnBhcmVudEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgIHRoaXMuaGFuZGxlUmVzaXplKCk7XG4gIH07XG4gIC8vIFZpc3VhbCB2aWV3cG9ydCByZXNpemUgaGFuZGxlciwgbWFpbmx5IHVzZWQgdG8gcmVhY3QgdG8gYnJvd3NlciB6b29tIGNoYW5nZXMuXG4gIC8vIFdhaXQgMiBmcmFtZXMgdG8gYWxpZ24gd2l0aCB3aGVuIHRoZSByZXNpemUgb2JzZXJ2ZXIgY2FsbGJhY2sgaXMgZG9uZSAoaW4gY2FzZSBpdCBtaWdodCBmb2xsb3cpOlxuICAvLyAtIEZyYW1lIDE6IGEgcGFpbnQgYWZ0ZXIgdGhlIHZpc3VhbCB2aWV3cG9ydCByZXNpemVcbiAgLy8gLSBGcmFtZSAyOiBhIHBhaW50IGFmdGVyIHRoZSByZXNpemUgb2JzZXJ2ZXIgaGFzIGJlZW4gaGFuZGxlZCwgaWYgaXQgd2FzIGV2ZXIgdHJpZ2dlcmVkXG4gIC8vXG4gIC8vIEJvdGggcmVzaXplIG9ic2VydmVyIGFuZCB2aXN1YWwgdmlld3BvcnQgd2lsbCByZWFjdCB0byBjbGFzc2ljIGJyb3dzZXIgem9vbSBjaGFuZ2VzLFxuICAvLyBzbyB3ZSBkZWR1cGUgdGhlIGNhbGxiYWNrcywgYnV0IHBpbmNoIHpvb20gb25seSB0cmlnZ2VycyB0aGUgdmlzdWFsIHZpZXdwb3J0IGhhbmRsZXIuXG4gIHJlc2l6ZVJhZklkID0gbnVsbDtcbiAgaGFuZGxlVmlzdWFsVmlld3BvcnRDaGFuZ2UgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMucmVzaXplUmFmSWQgIT09IG51bGwpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmVzaXplUmFmSWQpO1xuICAgIH1cbiAgICB0aGlzLnJlc2l6ZVJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMucmVzaXplUmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB0aGlzLmhhbmRsZVJlc2l6ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIC8qKiBSZXNpemUgaGFuZGxlciBmb3Igd2hlbiB0aGUgY29udGFpbmVyIGRpdiBjaGFuZ2VzIHNpemUgb3IgdGhlIG1heCBwaXhlbCBjb3VudCBjaGFuZ2VzIGFuZCB3ZSB3YW50IHRvIHJlc2l6ZSBvdXIgY2FudmFzIHRvIG1hdGNoICovXG4gIGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5yZXNpemVSYWZJZCAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yZXNpemVSYWZJZCk7XG4gICAgfVxuICAgIGNvbnN0IHBpbmNoWm9vbSA9IHZpc3VhbFZpZXdwb3J0Py5zY2FsZSA/PyAxO1xuICAgIGNvbnN0IHNjcm9sbGJhcldpZHRoID0gd2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgY29uc3QgaW5uZXJXaWR0aCA9IHZpc3VhbFZpZXdwb3J0ID8gdmlzdWFsVmlld3BvcnQuc2NhbGUgKiB2aXN1YWxWaWV3cG9ydC53aWR0aCArIHNjcm9sbGJhcldpZHRoIDogd2luZG93LmlubmVyV2lkdGg7XG4gICAgY29uc3QgY2xhc3NpY1pvb20gPSBNYXRoLnJvdW5kKDFlNCAqIHdpbmRvdy5vdXRlcldpZHRoIC8gaW5uZXJXaWR0aCkgLyAxZTQ7XG4gICAgY29uc3QgcmVhbFBpeGVsUmF0aW8gPSB0aGlzLmlzU2FmYXJpID8gZGV2aWNlUGl4ZWxSYXRpbyA6IGRldmljZVBpeGVsUmF0aW8gLyBjbGFzc2ljWm9vbTtcbiAgICBjb25zdCB0YXJnZXRQaXhlbFJhdGlvID0gTWF0aC5tYXgocmVhbFBpeGVsUmF0aW8sIHRoaXMubWluUGl4ZWxSYXRpbyk7XG4gICAgY29uc3QgdGFyZ2V0UmVuZGVyU2NhbGUgPSB0YXJnZXRQaXhlbFJhdGlvICogY2xhc3NpY1pvb20gKiBwaW5jaFpvb207XG4gICAgY29uc3QgdGFyZ2V0UGl4ZWxXaWR0aCA9IHRoaXMucGFyZW50V2lkdGggKiB0YXJnZXRSZW5kZXJTY2FsZTtcbiAgICBjb25zdCB0YXJnZXRQaXhlbEhlaWdodCA9IHRoaXMucGFyZW50SGVpZ2h0ICogdGFyZ2V0UmVuZGVyU2NhbGU7XG4gICAgY29uc3QgbWF4UGl4ZWxDb3VudEhlYWRyb29tID0gTWF0aC5zcXJ0KHRoaXMubWF4UGl4ZWxDb3VudCkgLyBNYXRoLnNxcnQodGFyZ2V0UGl4ZWxXaWR0aCAqIHRhcmdldFBpeGVsSGVpZ2h0KTtcbiAgICBjb25zdCBuZXdSZW5kZXJTY2FsZSA9IHRhcmdldFJlbmRlclNjYWxlICogTWF0aC5taW4oMSwgbWF4UGl4ZWxDb3VudEhlYWRyb29tKTtcbiAgICBjb25zdCBuZXdXaWR0aCA9IE1hdGgucm91bmQodGhpcy5wYXJlbnRXaWR0aCAqIG5ld1JlbmRlclNjYWxlKTtcbiAgICBjb25zdCBuZXdIZWlnaHQgPSBNYXRoLnJvdW5kKHRoaXMucGFyZW50SGVpZ2h0ICogbmV3UmVuZGVyU2NhbGUpO1xuICAgIGlmICh0aGlzLmNhbnZhc0VsZW1lbnQud2lkdGggIT09IG5ld1dpZHRoIHx8IHRoaXMuY2FudmFzRWxlbWVudC5oZWlnaHQgIT09IG5ld0hlaWdodCB8fCB0aGlzLnJlbmRlclNjYWxlICE9PSBuZXdSZW5kZXJTY2FsZSkge1xuICAgICAgdGhpcy5yZW5kZXJTY2FsZSA9IG5ld1JlbmRlclNjYWxlO1xuICAgICAgdGhpcy5jYW52YXNFbGVtZW50LndpZHRoID0gbmV3V2lkdGg7XG4gICAgICB0aGlzLmNhbnZhc0VsZW1lbnQuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgdGhpcy5yZXNvbHV0aW9uQ2hhbmdlZCA9IHRydWU7XG4gICAgICB0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIHRoaXMuZ2wuY2FudmFzLndpZHRoLCB0aGlzLmdsLmNhbnZhcy5oZWlnaHQpO1xuICAgICAgdGhpcy5yZW5kZXIocGVyZm9ybWFuY2Uubm93KCkpO1xuICAgIH1cbiAgfTtcbiAgcmVuZGVyID0gKGN1cnJlbnRUaW1lKSA9PiB7XG4gICAgaWYgKHRoaXMuaGFzQmVlbkRpc3Bvc2VkKSByZXR1cm47XG4gICAgaWYgKHRoaXMucHJvZ3JhbSA9PT0gbnVsbCkge1xuICAgICAgY29uc29sZS53YXJuKFwiVHJpZWQgdG8gcmVuZGVyIGJlZm9yZSBwcm9ncmFtIG9yIGdsIHdhcyBpbml0aWFsaXplZFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZHQgPSBjdXJyZW50VGltZSAtIHRoaXMubGFzdFJlbmRlclRpbWU7XG4gICAgdGhpcy5sYXN0UmVuZGVyVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIGlmICh0aGlzLnNwZWVkICE9PSAwKSB7XG4gICAgICB0aGlzLmN1cnJlbnRGcmFtZSArPSBkdCAqIHRoaXMuc3BlZWQ7XG4gICAgfVxuICAgIHRoaXMuZ2wuY2xlYXIodGhpcy5nbC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICB0aGlzLmdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICB0aGlzLmdsLnVuaWZvcm0xZih0aGlzLnVuaWZvcm1Mb2NhdGlvbnMudV90aW1lLCB0aGlzLmN1cnJlbnRGcmFtZSAqIDFlLTMpO1xuICAgIGlmICh0aGlzLnJlc29sdXRpb25DaGFuZ2VkKSB7XG4gICAgICB0aGlzLmdsLnVuaWZvcm0yZih0aGlzLnVuaWZvcm1Mb2NhdGlvbnMudV9yZXNvbHV0aW9uLCB0aGlzLmdsLmNhbnZhcy53aWR0aCwgdGhpcy5nbC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgIHRoaXMuZ2wudW5pZm9ybTFmKHRoaXMudW5pZm9ybUxvY2F0aW9ucy51X3BpeGVsUmF0aW8sIHRoaXMucmVuZGVyU2NhbGUpO1xuICAgICAgdGhpcy5yZXNvbHV0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmdsLmRyYXdBcnJheXModGhpcy5nbC5UUklBTkdMRVMsIDAsIDYpO1xuICAgIGlmICh0aGlzLnNwZWVkICE9PSAwKSB7XG4gICAgICB0aGlzLnJlcXVlc3RSZW5kZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yYWZJZCA9IG51bGw7XG4gICAgfVxuICB9O1xuICByZXF1ZXN0UmVuZGVyID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLnJhZklkICE9PSBudWxsKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJhZklkKTtcbiAgICB9XG4gICAgdGhpcy5yYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnJlbmRlcik7XG4gIH07XG4gIC8qKiBDcmVhdGVzIGEgdGV4dHVyZSBmcm9tIGFuIGltYWdlIGFuZCBzZXRzIGl0IGludG8gYSB1bmlmb3JtIHZhbHVlICovXG4gIHNldFRleHR1cmVVbmlmb3JtID0gKHVuaWZvcm1OYW1lLCBpbWFnZSkgPT4ge1xuICAgIGlmICghaW1hZ2UuY29tcGxldGUgfHwgaW1hZ2UubmF0dXJhbFdpZHRoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcGVyIFNoYWRlcnM6IGltYWdlIGZvciB1bmlmb3JtICR7dW5pZm9ybU5hbWV9IG11c3QgYmUgZnVsbHkgbG9hZGVkYCk7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nVGV4dHVyZSA9IHRoaXMudGV4dHVyZXMuZ2V0KHVuaWZvcm1OYW1lKTtcbiAgICBpZiAoZXhpc3RpbmdUZXh0dXJlKSB7XG4gICAgICB0aGlzLmdsLmRlbGV0ZVRleHR1cmUoZXhpc3RpbmdUZXh0dXJlKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnRleHR1cmVVbml0TWFwLmhhcyh1bmlmb3JtTmFtZSkpIHtcbiAgICAgIHRoaXMudGV4dHVyZVVuaXRNYXAuc2V0KHVuaWZvcm1OYW1lLCB0aGlzLnRleHR1cmVVbml0TWFwLnNpemUpO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0dXJlVW5pdCA9IHRoaXMudGV4dHVyZVVuaXRNYXAuZ2V0KHVuaWZvcm1OYW1lKTtcbiAgICB0aGlzLmdsLmFjdGl2ZVRleHR1cmUodGhpcy5nbC5URVhUVVJFMCArIHRleHR1cmVVbml0KTtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5nbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgdGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMuZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX1dSQVBfVCwgdGhpcy5nbC5DTEFNUF9UT19FREdFKTtcbiAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5nbC5MSU5FQVIpO1xuICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB0aGlzLmdsLkxJTkVBUik7XG4gICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMuZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuVU5TSUdORURfQllURSwgaW1hZ2UpO1xuICAgIGNvbnN0IGVycm9yID0gdGhpcy5nbC5nZXRFcnJvcigpO1xuICAgIGlmIChlcnJvciAhPT0gdGhpcy5nbC5OT19FUlJPUiB8fCB0ZXh0dXJlID09PSBudWxsKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiUGFwZXIgU2hhZGVyczogV2ViR0wgZXJyb3Igd2hlbiB1cGxvYWRpbmcgdGV4dHVyZTpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnRleHR1cmVzLnNldCh1bmlmb3JtTmFtZSwgdGV4dHVyZSk7XG4gICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLnVuaWZvcm1Mb2NhdGlvbnNbdW5pZm9ybU5hbWVdO1xuICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgdGhpcy5nbC51bmlmb3JtMWkobG9jYXRpb24sIHRleHR1cmVVbml0KTtcbiAgICAgIGNvbnN0IGFzcGVjdFJhdGlvVW5pZm9ybU5hbWUgPSBgJHt1bmlmb3JtTmFtZX1Bc3BlY3RSYXRpb2A7XG4gICAgICBjb25zdCBhc3BlY3RSYXRpb0xvY2F0aW9uID0gdGhpcy51bmlmb3JtTG9jYXRpb25zW2FzcGVjdFJhdGlvVW5pZm9ybU5hbWVdO1xuICAgICAgaWYgKGFzcGVjdFJhdGlvTG9jYXRpb24pIHtcbiAgICAgICAgY29uc3QgYXNwZWN0UmF0aW8gPSBpbWFnZS5uYXR1cmFsV2lkdGggLyBpbWFnZS5uYXR1cmFsSGVpZ2h0O1xuICAgICAgICB0aGlzLmdsLnVuaWZvcm0xZihhc3BlY3RSYXRpb0xvY2F0aW9uLCBhc3BlY3RSYXRpbyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKiogVXRpbGl0eTogcmVjdXJzaXZlIGVxdWFsaXR5IHRlc3QgZm9yIGFsbCB0aGUgdW5pZm9ybXMgKi9cbiAgYXJlVW5pZm9ybVZhbHVlc0VxdWFsID0gKGEsIGIpID0+IHtcbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSAmJiBhLmxlbmd0aCA9PT0gYi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBhLmV2ZXJ5KCh2YWwsIGkpID0+IHRoaXMuYXJlVW5pZm9ybVZhbHVlc0VxdWFsKHZhbCwgYltpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIC8qKiBTZXRzIHRoZSBwcm92aWRlZCB1bmlmb3JtIHZhbHVlcyBpbnRvIHRoZSBXZWJHTCBwcm9ncmFtLCBjYW4gYmUgYSBwYXJ0aWFsIGxpc3Qgb2YgdW5pZm9ybXMgdGhhdCBoYXZlIGNoYW5nZWQgKi9cbiAgc2V0VW5pZm9ybVZhbHVlcyA9ICh1cGRhdGVkVW5pZm9ybXMpID0+IHtcbiAgICB0aGlzLmdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICBPYmplY3QuZW50cmllcyh1cGRhdGVkVW5pZm9ybXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgbGV0IGNhY2hlVmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgICAgY2FjaGVWYWx1ZSA9IGAke3ZhbHVlLnNyYy5zbGljZSgwLCAyMDApfXwke3ZhbHVlLm5hdHVyYWxXaWR0aH14JHt2YWx1ZS5uYXR1cmFsSGVpZ2h0fWA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5hcmVVbmlmb3JtVmFsdWVzRXF1YWwodGhpcy51bmlmb3JtQ2FjaGVba2V5XSwgY2FjaGVWYWx1ZSkpIHJldHVybjtcbiAgICAgIHRoaXMudW5pZm9ybUNhY2hlW2tleV0gPSBjYWNoZVZhbHVlO1xuICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLnVuaWZvcm1Mb2NhdGlvbnNba2V5XTtcbiAgICAgIGlmICghbG9jYXRpb24pIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBVbmlmb3JtIGxvY2F0aW9uIGZvciAke2tleX0gbm90IGZvdW5kYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5zZXRUZXh0dXJlVW5pZm9ybShrZXksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgbGV0IGZsYXRBcnJheSA9IG51bGw7XG4gICAgICAgIGxldCB2YWx1ZUxlbmd0aCA9IG51bGw7XG4gICAgICAgIGlmICh2YWx1ZVswXSAhPT0gdm9pZCAwICYmIEFycmF5LmlzQXJyYXkodmFsdWVbMF0pKSB7XG4gICAgICAgICAgY29uc3QgZmlyc3RDaGlsZExlbmd0aCA9IHZhbHVlWzBdLmxlbmd0aDtcbiAgICAgICAgICBpZiAodmFsdWUuZXZlcnkoKGFycikgPT4gYXJyLmxlbmd0aCA9PT0gZmlyc3RDaGlsZExlbmd0aCkpIHtcbiAgICAgICAgICAgIGZsYXRBcnJheSA9IHZhbHVlLmZsYXQoKTtcbiAgICAgICAgICAgIHZhbHVlTGVuZ3RoID0gZmlyc3RDaGlsZExlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBBbGwgY2hpbGQgYXJyYXlzIG11c3QgYmUgdGhlIHNhbWUgbGVuZ3RoIGZvciAke2tleX1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmxhdEFycmF5ID0gdmFsdWU7XG4gICAgICAgICAgdmFsdWVMZW5ndGggPSBmbGF0QXJyYXkubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodmFsdWVMZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0aGlzLmdsLnVuaWZvcm0yZnYobG9jYXRpb24sIGZsYXRBcnJheSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB0aGlzLmdsLnVuaWZvcm0zZnYobG9jYXRpb24sIGZsYXRBcnJheSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB0aGlzLmdsLnVuaWZvcm00ZnYobG9jYXRpb24sIGZsYXRBcnJheSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICB0aGlzLmdsLnVuaWZvcm1NYXRyaXgzZnYobG9jYXRpb24sIGZhbHNlLCBmbGF0QXJyYXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIHRoaXMuZ2wudW5pZm9ybU1hdHJpeDRmdihsb2NhdGlvbiwgZmFsc2UsIGZsYXRBcnJheSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbnN1cHBvcnRlZCB1bmlmb3JtIGFycmF5IGxlbmd0aDogJHt2YWx1ZUxlbmd0aH1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdGhpcy5nbC51bmlmb3JtMWYobG9jYXRpb24sIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICB0aGlzLmdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdmFsdWUgPyAxIDogMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oYFVuc3VwcG9ydGVkIHVuaWZvcm0gdHlwZSBmb3IgJHtrZXl9OiAke3R5cGVvZiB2YWx1ZX1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgLyoqIEdldHMgdGhlIGN1cnJlbnQgdG90YWwgYW5pbWF0aW9uIHRpbWUgZnJvbSAwbXMgKi9cbiAgZ2V0Q3VycmVudEZyYW1lID0gKCkgPT4ge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRGcmFtZTtcbiAgfTtcbiAgLyoqIFNldCBhIGZyYW1lIHRvIGdldCBhIGRldGVybWluaXN0aWMgcmVzdWx0LCBmcmFtZXMgYXJlIGxpdGVyYWxseSBqdXN0IG1pbGxpc2Vjb25kcyBmcm9tIHplcm8gc2luY2UgdGhlIGFuaW1hdGlvbiBzdGFydGVkICovXG4gIHNldEZyYW1lID0gKG5ld0ZyYW1lKSA9PiB7XG4gICAgdGhpcy5jdXJyZW50RnJhbWUgPSBuZXdGcmFtZTtcbiAgICB0aGlzLmxhc3RSZW5kZXJUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdGhpcy5yZW5kZXIocGVyZm9ybWFuY2Uubm93KCkpO1xuICB9O1xuICAvKiogU2V0IGFuIGFuaW1hdGlvbiBzcGVlZCAob3IgMCB0byBzdG9wIGFuaW1hdGlvbikgKi9cbiAgc2V0U3BlZWQgPSAobmV3U3BlZWQgPSAxKSA9PiB7XG4gICAgdGhpcy5zcGVlZCA9IG5ld1NwZWVkO1xuICAgIGlmICh0aGlzLnJhZklkID09PSBudWxsICYmIG5ld1NwZWVkICE9PSAwKSB7XG4gICAgICB0aGlzLmxhc3RSZW5kZXJUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB0aGlzLnJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMucmVuZGVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucmFmSWQgIT09IG51bGwgJiYgbmV3U3BlZWQgPT09IDApIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmFmSWQpO1xuICAgICAgdGhpcy5yYWZJZCA9IG51bGw7XG4gICAgfVxuICB9O1xuICAvKiogU2V0IHRoZSBtYXhpbXVtIHBpeGVsIGNvdW50IGZvciB0aGUgc2hhZGVyLCB0aGlzIHdpbGwgbGltaXQgdGhlIG51bWJlciBvZiBwaXhlbHMgdGhhdCB3aWxsIGJlIHJlbmRlcmVkICovXG4gIHNldE1heFBpeGVsQ291bnQgPSAobmV3TWF4UGl4ZWxDb3VudCA9IERFRkFVTFRfTUFYX1BJWEVMX0NPVU5UKSA9PiB7XG4gICAgdGhpcy5tYXhQaXhlbENvdW50ID0gbmV3TWF4UGl4ZWxDb3VudDtcbiAgICB0aGlzLmhhbmRsZVJlc2l6ZSgpO1xuICB9O1xuICAvKiogU2V0IHRoZSBtaW5pbXVtIHBpeGVsIHJhdGlvIGZvciB0aGUgc2hhZGVyICovXG4gIHNldE1pblBpeGVsUmF0aW8gPSAobmV3TWluUGl4ZWxSYXRpbyA9IDIpID0+IHtcbiAgICB0aGlzLm1pblBpeGVsUmF0aW8gPSBuZXdNaW5QaXhlbFJhdGlvO1xuICAgIHRoaXMuaGFuZGxlUmVzaXplKCk7XG4gIH07XG4gIC8qKiBVcGRhdGUgdGhlIHVuaWZvcm1zIHRoYXQgYXJlIHByb3ZpZGVkIGJ5IHRoZSBvdXRzaWRlIHNoYWRlciwgY2FuIGJlIGEgcGFydGlhbCBzZXQgd2l0aCBvbmx5IHRoZSB1bmlmb3JtcyB0aGF0IGhhdmUgY2hhbmdlZCAqL1xuICBzZXRVbmlmb3JtcyA9IChuZXdVbmlmb3JtcykgPT4ge1xuICAgIHRoaXMuc2V0VW5pZm9ybVZhbHVlcyhuZXdVbmlmb3Jtcyk7XG4gICAgdGhpcy5wcm92aWRlZFVuaWZvcm1zID0geyAuLi50aGlzLnByb3ZpZGVkVW5pZm9ybXMsIC4uLm5ld1VuaWZvcm1zIH07XG4gICAgdGhpcy5yZW5kZXIocGVyZm9ybWFuY2Uubm93KCkpO1xuICB9O1xuICAvKiogRGlzcG9zZSBvZiB0aGUgc2hhZGVyIG1vdW50LCBjbGVhbmluZyB1cCBhbGwgb2YgdGhlIFdlYkdMIHJlc291cmNlcyAqL1xuICBkaXNwb3NlID0gKCkgPT4ge1xuICAgIHRoaXMuaGFzQmVlbkRpc3Bvc2VkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5yYWZJZCAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yYWZJZCk7XG4gICAgICB0aGlzLnJhZklkID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2wgJiYgdGhpcy5wcm9ncmFtKSB7XG4gICAgICB0aGlzLnRleHR1cmVzLmZvckVhY2goKHRleHR1cmUpID0+IHtcbiAgICAgICAgdGhpcy5nbC5kZWxldGVUZXh0dXJlKHRleHR1cmUpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnRleHR1cmVzLmNsZWFyKCk7XG4gICAgICB0aGlzLmdsLmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG4gICAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIG51bGwpO1xuICAgICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG51bGwpO1xuICAgICAgdGhpcy5nbC5iaW5kUmVuZGVyYnVmZmVyKHRoaXMuZ2wuUkVOREVSQlVGRkVSLCBudWxsKTtcbiAgICAgIHRoaXMuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgdGhpcy5nbC5nZXRFcnJvcigpO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZXNpemVPYnNlcnZlcikge1xuICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgICB9XG4gICAgdmlzdWFsVmlld3BvcnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5oYW5kbGVWaXN1YWxWaWV3cG9ydENoYW5nZSk7XG4gICAgdGhpcy51bmlmb3JtTG9jYXRpb25zID0ge307XG4gICAgdGhpcy5wYXJlbnRFbGVtZW50LnBhcGVyU2hhZGVyTW91bnQgPSB2b2lkIDA7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTaGFkZXIoZ2wsIHR5cGUsIHNvdXJjZSkge1xuICBjb25zdCBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XG4gIGlmICghc2hhZGVyKSByZXR1cm4gbnVsbDtcbiAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc291cmNlKTtcbiAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJBbiBlcnJvciBvY2N1cnJlZCBjb21waWxpbmcgdGhlIHNoYWRlcnM6IFwiICsgZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcbiAgICBnbC5kZWxldGVTaGFkZXIoc2hhZGVyKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gc2hhZGVyO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbShnbCwgdmVydGV4U2hhZGVyU291cmNlMiwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpIHtcbiAgY29uc3QgZm9ybWF0ID0gZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTUVESVVNX0ZMT0FUKTtcbiAgY29uc3QgcHJlY2lzaW9uID0gZm9ybWF0ID8gZm9ybWF0LnByZWNpc2lvbiA6IG51bGw7XG4gIGlmIChwcmVjaXNpb24gJiYgcHJlY2lzaW9uIDwgMjMpIHtcbiAgICB2ZXJ0ZXhTaGFkZXJTb3VyY2UyID0gdmVydGV4U2hhZGVyU291cmNlMi5yZXBsYWNlKC9wcmVjaXNpb25cXHMrKGxvd3B8bWVkaXVtcClcXHMrZmxvYXQ7L2csIFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1wiKTtcbiAgICBmcmFnbWVudFNoYWRlclNvdXJjZSA9IGZyYWdtZW50U2hhZGVyU291cmNlLnJlcGxhY2UoL3ByZWNpc2lvblxccysobG93cHxtZWRpdW1wKVxccytmbG9hdC9nLCBcInByZWNpc2lvbiBoaWdocCBmbG9hdFwiKS5yZXBsYWNlKC9cXGIodW5pZm9ybXx2YXJ5aW5nfGF0dHJpYnV0ZSlcXHMrKGxvd3B8bWVkaXVtcClcXHMrKFxcdyspL2csIFwiJDEgaGlnaHAgJDNcIik7XG4gIH1cbiAgY29uc3QgdmVydGV4U2hhZGVyID0gY3JlYXRlU2hhZGVyKGdsLCBnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UyKTtcbiAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSBjcmVhdGVTaGFkZXIoZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpO1xuICBpZiAoIXZlcnRleFNoYWRlciB8fCAhZnJhZ21lbnRTaGFkZXIpIHJldHVybiBudWxsO1xuICBjb25zdCBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICBpZiAoIXByb2dyYW0pIHJldHVybiBudWxsO1xuICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcbiAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG4gIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVW5hYmxlIHRvIGluaXRpYWxpemUgdGhlIHNoYWRlciBwcm9ncmFtOiBcIiArIGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcbiAgICBnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xuICAgIGdsLmRlbGV0ZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuICAgIGdsLmRlbGV0ZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2wuZGV0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gIGdsLmRldGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gIGdsLmRlbGV0ZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuICBnbC5kZWxldGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuICByZXR1cm4gcHJvZ3JhbTtcbn1cbmNvbnN0IGRlZmF1bHRTdHlsZSA9IGBAbGF5ZXIgcGFwZXItc2hhZGVycyB7XG4gIDp3aGVyZShbZGF0YS1wYXBlci1zaGFkZXJdKSB7XG4gICAgaXNvbGF0aW9uOiBpc29sYXRlO1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcblxuICAgICYgY2FudmFzIHtcbiAgICAgIGNvbnRhaW46IHN0cmljdDtcbiAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgaW5zZXQ6IDA7XG4gICAgICB6LWluZGV4OiAtMTtcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgYm9yZGVyLXJhZGl1czogaW5oZXJpdDtcbiAgICB9XG4gIH1cbn1gO1xuZnVuY3Rpb24gaXNQYXBlclNoYWRlckVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gXCJwYXBlclNoYWRlck1vdW50XCIgaW4gZWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzU2FmYXJpKCkge1xuICBjb25zdCB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIHVhLmluY2x1ZGVzKFwic2FmYXJpXCIpICYmICF1YS5pbmNsdWRlcyhcImNocm9tZVwiKSAmJiAhdWEuaW5jbHVkZXMoXCJhbmRyb2lkXCIpO1xufVxuZXhwb3J0IHtcbiAgU2hhZGVyTW91bnQsXG4gIGlzUGFwZXJTaGFkZXJFbGVtZW50XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhZGVyLW1vdW50LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/shader-mount.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js":
/*!******************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/shader-sizing.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShaderFitOptions: () => (/* binding */ ShaderFitOptions),\n/* harmony export */   defaultObjectSizing: () => (/* binding */ defaultObjectSizing),\n/* harmony export */   defaultPatternSizing: () => (/* binding */ defaultPatternSizing),\n/* harmony export */   drawSizingHelpers: () => (/* binding */ drawSizingHelpers),\n/* harmony export */   sizingDebugVariablesDeclaration: () => (/* binding */ sizingDebugVariablesDeclaration),\n/* harmony export */   sizingUV: () => (/* binding */ sizingUV),\n/* harmony export */   sizingUniformsDeclaration: () => (/* binding */ sizingUniformsDeclaration),\n/* harmony export */   sizingVariablesDeclaration: () => (/* binding */ sizingVariablesDeclaration)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nconst sizingVariablesDeclaration = `\nin vec2 v_objectUV;\nin vec2 v_responsiveUV;\nin vec2 v_responsiveBoxGivenSize;\nin vec2 v_patternUV;\nin vec2 v_imageUV;`;\nconst sizingDebugVariablesDeclaration = `\nin vec2 v_objectBoxSize;\nin vec2 v_objectHelperBox;\nin vec2 v_responsiveBoxSize;\nin vec2 v_responsiveHelperBox;\nin vec2 v_patternBoxSize;\nin vec2 v_patternHelperBox;`;\nconst sizingUniformsDeclaration = `\nuniform float u_originX;\nuniform float u_originY;\nuniform float u_worldWidth;\nuniform float u_worldHeight;\nuniform float u_fit;\n\nuniform float u_scale;\nuniform float u_rotation;\nuniform float u_offsetX;\nuniform float u_offsetY;`;\nconst sizingUV = `\n\n  vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n  #ifdef USE_PIXELIZATION\n    float pxSize = u_pxSize * u_pixelRatio;\n    vec2 pxSizeUv = gl_FragCoord.xy;\n    pxSizeUv -= .5 * u_resolution;\n    pxSizeUv /= pxSize;\n    uv = floor(pxSizeUv) * pxSize / u_resolution.xy;    \n    uv += .5;\n  #endif\n  uv -= .5;\n\n  \n  // ===================================================\n  // sizing params shared between objects and patterns\n  \n  vec2 boxOrigin = vec2(.5 - u_originX, u_originY - .5);\n  vec2 givenBoxSize = vec2(u_worldWidth, u_worldHeight);\n  givenBoxSize = max(givenBoxSize, vec2(1.)) * u_pixelRatio;\n  vec2 maxBoxSize = vec2(max(u_resolution.x, givenBoxSize.x), max(u_resolution.y, givenBoxSize.y));\n  float r = u_rotation * 3.14159265358979323846 / 180.;\n  mat2 graphicRotation = mat2(cos(r), sin(r), -sin(r), cos(r));\n  vec2 graphicOffset = vec2(-u_offsetX, u_offsetY);\n\n  \n  // ===================================================\n  // Sizing api for objects (graphics with fixed ratio)\n\n  #ifdef USE_OBJECT_SIZING\n    float fixedRatio = 1.;\n    vec2 fixedRatioBoxGivenSize = vec2(\n      (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n      (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n    );\n    vec2 objectBoxSize = vec2(0.);\n    // fit = none\n    objectBoxSize.x = fixedRatio * min(fixedRatioBoxGivenSize.x / fixedRatio, fixedRatioBoxGivenSize.y);\n    if (u_fit == 1.) { // fit = contain\n      objectBoxSize.x = fixedRatio * min(maxBoxSize.x / fixedRatio, maxBoxSize.y);\n    } else if (u_fit == 2.) {  // fit = cover\n      objectBoxSize.x = fixedRatio * max(maxBoxSize.x / fixedRatio, maxBoxSize.y);\n    }\n    objectBoxSize.y = objectBoxSize.x / fixedRatio;\n    vec2 objectWorldScale = u_resolution.xy / objectBoxSize;\n  \n    #ifdef ADD_HELPERS\n      vec2 objectHelperBox = gl_FragCoord.xy / u_resolution.xy;\n      objectHelperBox -= .5;\n      objectHelperBox *= objectWorldScale;\n      objectHelperBox += boxOrigin * (objectWorldScale - 1.);  \n    #endif\n  \n    vec2 objectUV = uv;\n    objectUV *= objectWorldScale;\n    objectUV += boxOrigin * (objectWorldScale - 1.);\n    objectUV += vec2(-u_offsetX, u_offsetY);\n    objectUV /= u_scale;\n    objectUV = graphicRotation * objectUV;\n  #endif\n  \n  // ===================================================\n \n  // ===================================================\n  // Sizing api for patterns (graphics respecting u_worldWidth / u_worldHeight ratio)\n  \n  #ifdef USE_PATTERN_SIZING\n    float patternBoxRatio = givenBoxSize.x / givenBoxSize.y;\n    vec2 patternBoxGivenSize = vec2(\n      (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n      (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n    );\n    vec2 patternBoxSize = vec2(0.);\n    // fit = none\n    patternBoxSize.x = patternBoxRatio * min(patternBoxGivenSize.x / patternBoxRatio, patternBoxGivenSize.y);\n    float patternWorldNoFitBoxWidth = patternBoxSize.x;\n    if (u_fit == 1.) {  // fit = contain\n      patternBoxSize.x = patternBoxRatio * min(maxBoxSize.x / patternBoxRatio, maxBoxSize.y);\n    } else if (u_fit == 2.) {  // fit = cover\n      patternBoxSize.x = patternBoxRatio * max(maxBoxSize.x / patternBoxRatio, maxBoxSize.y);\n    }\n    patternBoxSize.y = patternBoxSize.x / patternBoxRatio;\n    vec2 patternWorldScale = u_resolution.xy / patternBoxSize;\n  \n    #ifdef ADD_HELPERS  \n      vec2 patternHelperBox = gl_FragCoord.xy / u_resolution.xy;\n      patternHelperBox -= .5;\n      patternHelperBox *= patternWorldScale;\n      patternHelperBox += boxOrigin * (patternWorldScale - 1.);  \n    #endif\n  \n    vec2 patternUV = uv;\n    patternUV += vec2(-u_offsetX, u_offsetY) / patternWorldScale;\n    patternUV += boxOrigin;\n    patternUV -= boxOrigin / patternWorldScale;\n    patternUV *= u_resolution.xy;\n    patternUV /= u_pixelRatio;\n    if (u_fit > 0.) {\n      patternUV *= (patternWorldNoFitBoxWidth / patternBoxSize.x);\n    }\n    patternUV /= u_scale;\n    patternUV = graphicRotation * patternUV;\n    patternUV += boxOrigin / patternWorldScale;\n    patternUV -= boxOrigin;\n    patternUV += .5;\n  #endif\n    \n  // ===================================================\n \n  // ===================================================\n  // Sizing api for image filters\n  \n  #ifdef USE_IMAGE_SIZING\n\n    vec2 imageBoxSize;\n    if (u_fit == 1.) { // contain\n      imageBoxSize.x = min(maxBoxSize.x / u_imageAspectRatio, maxBoxSize.y) * u_imageAspectRatio;\n    } else if (u_fit == 2.) { // cover\n      imageBoxSize.x = max(maxBoxSize.x / u_imageAspectRatio, maxBoxSize.y) * u_imageAspectRatio;\n    } else {\n      imageBoxSize.x = min(10.0, 10.0 / u_imageAspectRatio * u_imageAspectRatio);\n    }\n    imageBoxSize.y = imageBoxSize.x / u_imageAspectRatio;\n    vec2 imageBoxScale = u_resolution.xy / imageBoxSize;\n\n    #ifdef ADD_HELPERS\n      vec2 imageHelperBox = uv;\n      imageHelperBox *= imageBoxScale;\n      imageHelperBox += boxOrigin * (imageBoxScale - 1.);\n    #endif\n\n    vec2 imageUV = uv;\n    imageUV *= imageBoxScale;\n    imageUV += boxOrigin * (imageBoxScale - 1.);\n    imageUV += graphicOffset;\n    imageUV /= u_scale;\n    imageUV.x *= u_imageAspectRatio;\n    imageUV = graphicRotation * imageUV;\n    imageUV.x /= u_imageAspectRatio;\n    \n    imageUV += .5;\n    imageUV.y = 1. - imageUV.y;\n  #endif\n`;\nconst drawSizingHelpers = `\n  vec2 worldBoxDist = abs(helperBox);\n  float boxStroke = (step(max(worldBoxDist.x, worldBoxDist.y), .5) - step(max(worldBoxDist.x, worldBoxDist.y), .495));\n  color.rgb = mix(color.rgb, vec3(1., 0., 0.), boxStroke);\n  opacity += boxStroke;\n\n  vec2 boxOriginCopy = vec2(.5 - u_originX, u_originY - .5);\n  vec2 boxOriginDist = helperBox + boxOriginCopy;\n  boxOriginDist.x *= (boxSize.x / boxSize.y);\n  float boxOriginPoint = 1. - smoothstep(0., .05, length(boxOriginDist));\n  \n  vec2 graphicOriginPointDist = helperBox + vec2(-u_offsetX, u_offsetY);\n  graphicOriginPointDist.x *= (boxSize.x / boxSize.y);\n  float graphicOriginPoint = 1. - smoothstep(0., .05, length(graphicOriginPointDist));\n  \n  color.rgb = mix(color.rgb, vec3(0., 1., 0.), boxOriginPoint);\n  opacity += boxOriginPoint;\n  color.rgb = mix(color.rgb, vec3(0., 0., 1.), graphicOriginPoint);\n  opacity += graphicOriginPoint;\n`;\nconst defaultObjectSizing = {\n  fit: \"contain\",\n  scale: 1,\n  rotation: 0,\n  offsetX: 0,\n  offsetY: 0,\n  originX: 0.5,\n  originY: 0.5,\n  worldWidth: 0,\n  worldHeight: 0\n};\nconst defaultPatternSizing = {\n  fit: \"none\",\n  scale: 1,\n  rotation: 0,\n  offsetX: 0,\n  offsetY: 0,\n  originX: 0.5,\n  originY: 0.5,\n  worldWidth: 0,\n  worldHeight: 0\n};\nconst ShaderFitOptions = {\n  none: 0,\n  contain: 1,\n  cover: 2\n};\n\n//# sourceMappingURL=shader-sizing.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLXNpemluZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsTUFBTSx5QkFBeUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLE1BQU0seUJBQXlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsTUFBTSx3QkFBd0I7QUFDOUI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVVFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLXNpemluZy5qcz8yYjY4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgICAgICAgICAgICAgICAgUGFwZXIgU2hhZGVycyAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3BhcGVyLWRlc2lnbi9zaGFkZXJzICAgICAgICpcbiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG5jb25zdCBzaXppbmdWYXJpYWJsZXNEZWNsYXJhdGlvbiA9IGBcbmluIHZlYzIgdl9vYmplY3RVVjtcbmluIHZlYzIgdl9yZXNwb25zaXZlVVY7XG5pbiB2ZWMyIHZfcmVzcG9uc2l2ZUJveEdpdmVuU2l6ZTtcbmluIHZlYzIgdl9wYXR0ZXJuVVY7XG5pbiB2ZWMyIHZfaW1hZ2VVVjtgO1xuY29uc3Qgc2l6aW5nRGVidWdWYXJpYWJsZXNEZWNsYXJhdGlvbiA9IGBcbmluIHZlYzIgdl9vYmplY3RCb3hTaXplO1xuaW4gdmVjMiB2X29iamVjdEhlbHBlckJveDtcbmluIHZlYzIgdl9yZXNwb25zaXZlQm94U2l6ZTtcbmluIHZlYzIgdl9yZXNwb25zaXZlSGVscGVyQm94O1xuaW4gdmVjMiB2X3BhdHRlcm5Cb3hTaXplO1xuaW4gdmVjMiB2X3BhdHRlcm5IZWxwZXJCb3g7YDtcbmNvbnN0IHNpemluZ1VuaWZvcm1zRGVjbGFyYXRpb24gPSBgXG51bmlmb3JtIGZsb2F0IHVfb3JpZ2luWDtcbnVuaWZvcm0gZmxvYXQgdV9vcmlnaW5ZO1xudW5pZm9ybSBmbG9hdCB1X3dvcmxkV2lkdGg7XG51bmlmb3JtIGZsb2F0IHVfd29ybGRIZWlnaHQ7XG51bmlmb3JtIGZsb2F0IHVfZml0O1xuXG51bmlmb3JtIGZsb2F0IHVfc2NhbGU7XG51bmlmb3JtIGZsb2F0IHVfcm90YXRpb247XG51bmlmb3JtIGZsb2F0IHVfb2Zmc2V0WDtcbnVuaWZvcm0gZmxvYXQgdV9vZmZzZXRZO2A7XG5jb25zdCBzaXppbmdVViA9IGBcblxuICB2ZWMyIHV2ID0gZ2xfRnJhZ0Nvb3JkLnh5IC8gdV9yZXNvbHV0aW9uLnh5O1xuICAjaWZkZWYgVVNFX1BJWEVMSVpBVElPTlxuICAgIGZsb2F0IHB4U2l6ZSA9IHVfcHhTaXplICogdV9waXhlbFJhdGlvO1xuICAgIHZlYzIgcHhTaXplVXYgPSBnbF9GcmFnQ29vcmQueHk7XG4gICAgcHhTaXplVXYgLT0gLjUgKiB1X3Jlc29sdXRpb247XG4gICAgcHhTaXplVXYgLz0gcHhTaXplO1xuICAgIHV2ID0gZmxvb3IocHhTaXplVXYpICogcHhTaXplIC8gdV9yZXNvbHV0aW9uLnh5OyAgICBcbiAgICB1diArPSAuNTtcbiAgI2VuZGlmXG4gIHV2IC09IC41O1xuXG4gIFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gc2l6aW5nIHBhcmFtcyBzaGFyZWQgYmV0d2VlbiBvYmplY3RzIGFuZCBwYXR0ZXJuc1xuICBcbiAgdmVjMiBib3hPcmlnaW4gPSB2ZWMyKC41IC0gdV9vcmlnaW5YLCB1X29yaWdpblkgLSAuNSk7XG4gIHZlYzIgZ2l2ZW5Cb3hTaXplID0gdmVjMih1X3dvcmxkV2lkdGgsIHVfd29ybGRIZWlnaHQpO1xuICBnaXZlbkJveFNpemUgPSBtYXgoZ2l2ZW5Cb3hTaXplLCB2ZWMyKDEuKSkgKiB1X3BpeGVsUmF0aW87XG4gIHZlYzIgbWF4Qm94U2l6ZSA9IHZlYzIobWF4KHVfcmVzb2x1dGlvbi54LCBnaXZlbkJveFNpemUueCksIG1heCh1X3Jlc29sdXRpb24ueSwgZ2l2ZW5Cb3hTaXplLnkpKTtcbiAgZmxvYXQgciA9IHVfcm90YXRpb24gKiAzLjE0MTU5MjY1MzU4OTc5MzIzODQ2IC8gMTgwLjtcbiAgbWF0MiBncmFwaGljUm90YXRpb24gPSBtYXQyKGNvcyhyKSwgc2luKHIpLCAtc2luKHIpLCBjb3MocikpO1xuICB2ZWMyIGdyYXBoaWNPZmZzZXQgPSB2ZWMyKC11X29mZnNldFgsIHVfb2Zmc2V0WSk7XG5cbiAgXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBTaXppbmcgYXBpIGZvciBvYmplY3RzIChncmFwaGljcyB3aXRoIGZpeGVkIHJhdGlvKVxuXG4gICNpZmRlZiBVU0VfT0JKRUNUX1NJWklOR1xuICAgIGZsb2F0IGZpeGVkUmF0aW8gPSAxLjtcbiAgICB2ZWMyIGZpeGVkUmF0aW9Cb3hHaXZlblNpemUgPSB2ZWMyKFxuICAgICAgKHVfd29ybGRXaWR0aCA9PSAwLikgPyB1X3Jlc29sdXRpb24ueCA6IGdpdmVuQm94U2l6ZS54LFxuICAgICAgKHVfd29ybGRIZWlnaHQgPT0gMC4pID8gdV9yZXNvbHV0aW9uLnkgOiBnaXZlbkJveFNpemUueVxuICAgICk7XG4gICAgdmVjMiBvYmplY3RCb3hTaXplID0gdmVjMigwLik7XG4gICAgLy8gZml0ID0gbm9uZVxuICAgIG9iamVjdEJveFNpemUueCA9IGZpeGVkUmF0aW8gKiBtaW4oZml4ZWRSYXRpb0JveEdpdmVuU2l6ZS54IC8gZml4ZWRSYXRpbywgZml4ZWRSYXRpb0JveEdpdmVuU2l6ZS55KTtcbiAgICBpZiAodV9maXQgPT0gMS4pIHsgLy8gZml0ID0gY29udGFpblxuICAgICAgb2JqZWN0Qm94U2l6ZS54ID0gZml4ZWRSYXRpbyAqIG1pbihtYXhCb3hTaXplLnggLyBmaXhlZFJhdGlvLCBtYXhCb3hTaXplLnkpO1xuICAgIH0gZWxzZSBpZiAodV9maXQgPT0gMi4pIHsgIC8vIGZpdCA9IGNvdmVyXG4gICAgICBvYmplY3RCb3hTaXplLnggPSBmaXhlZFJhdGlvICogbWF4KG1heEJveFNpemUueCAvIGZpeGVkUmF0aW8sIG1heEJveFNpemUueSk7XG4gICAgfVxuICAgIG9iamVjdEJveFNpemUueSA9IG9iamVjdEJveFNpemUueCAvIGZpeGVkUmF0aW87XG4gICAgdmVjMiBvYmplY3RXb3JsZFNjYWxlID0gdV9yZXNvbHV0aW9uLnh5IC8gb2JqZWN0Qm94U2l6ZTtcbiAgXG4gICAgI2lmZGVmIEFERF9IRUxQRVJTXG4gICAgICB2ZWMyIG9iamVjdEhlbHBlckJveCA9IGdsX0ZyYWdDb29yZC54eSAvIHVfcmVzb2x1dGlvbi54eTtcbiAgICAgIG9iamVjdEhlbHBlckJveCAtPSAuNTtcbiAgICAgIG9iamVjdEhlbHBlckJveCAqPSBvYmplY3RXb3JsZFNjYWxlO1xuICAgICAgb2JqZWN0SGVscGVyQm94ICs9IGJveE9yaWdpbiAqIChvYmplY3RXb3JsZFNjYWxlIC0gMS4pOyAgXG4gICAgI2VuZGlmXG4gIFxuICAgIHZlYzIgb2JqZWN0VVYgPSB1djtcbiAgICBvYmplY3RVViAqPSBvYmplY3RXb3JsZFNjYWxlO1xuICAgIG9iamVjdFVWICs9IGJveE9yaWdpbiAqIChvYmplY3RXb3JsZFNjYWxlIC0gMS4pO1xuICAgIG9iamVjdFVWICs9IHZlYzIoLXVfb2Zmc2V0WCwgdV9vZmZzZXRZKTtcbiAgICBvYmplY3RVViAvPSB1X3NjYWxlO1xuICAgIG9iamVjdFVWID0gZ3JhcGhpY1JvdGF0aW9uICogb2JqZWN0VVY7XG4gICNlbmRpZlxuICBcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBTaXppbmcgYXBpIGZvciBwYXR0ZXJucyAoZ3JhcGhpY3MgcmVzcGVjdGluZyB1X3dvcmxkV2lkdGggLyB1X3dvcmxkSGVpZ2h0IHJhdGlvKVxuICBcbiAgI2lmZGVmIFVTRV9QQVRURVJOX1NJWklOR1xuICAgIGZsb2F0IHBhdHRlcm5Cb3hSYXRpbyA9IGdpdmVuQm94U2l6ZS54IC8gZ2l2ZW5Cb3hTaXplLnk7XG4gICAgdmVjMiBwYXR0ZXJuQm94R2l2ZW5TaXplID0gdmVjMihcbiAgICAgICh1X3dvcmxkV2lkdGggPT0gMC4pID8gdV9yZXNvbHV0aW9uLnggOiBnaXZlbkJveFNpemUueCxcbiAgICAgICh1X3dvcmxkSGVpZ2h0ID09IDAuKSA/IHVfcmVzb2x1dGlvbi55IDogZ2l2ZW5Cb3hTaXplLnlcbiAgICApO1xuICAgIHZlYzIgcGF0dGVybkJveFNpemUgPSB2ZWMyKDAuKTtcbiAgICAvLyBmaXQgPSBub25lXG4gICAgcGF0dGVybkJveFNpemUueCA9IHBhdHRlcm5Cb3hSYXRpbyAqIG1pbihwYXR0ZXJuQm94R2l2ZW5TaXplLnggLyBwYXR0ZXJuQm94UmF0aW8sIHBhdHRlcm5Cb3hHaXZlblNpemUueSk7XG4gICAgZmxvYXQgcGF0dGVybldvcmxkTm9GaXRCb3hXaWR0aCA9IHBhdHRlcm5Cb3hTaXplLng7XG4gICAgaWYgKHVfZml0ID09IDEuKSB7ICAvLyBmaXQgPSBjb250YWluXG4gICAgICBwYXR0ZXJuQm94U2l6ZS54ID0gcGF0dGVybkJveFJhdGlvICogbWluKG1heEJveFNpemUueCAvIHBhdHRlcm5Cb3hSYXRpbywgbWF4Qm94U2l6ZS55KTtcbiAgICB9IGVsc2UgaWYgKHVfZml0ID09IDIuKSB7ICAvLyBmaXQgPSBjb3ZlclxuICAgICAgcGF0dGVybkJveFNpemUueCA9IHBhdHRlcm5Cb3hSYXRpbyAqIG1heChtYXhCb3hTaXplLnggLyBwYXR0ZXJuQm94UmF0aW8sIG1heEJveFNpemUueSk7XG4gICAgfVxuICAgIHBhdHRlcm5Cb3hTaXplLnkgPSBwYXR0ZXJuQm94U2l6ZS54IC8gcGF0dGVybkJveFJhdGlvO1xuICAgIHZlYzIgcGF0dGVybldvcmxkU2NhbGUgPSB1X3Jlc29sdXRpb24ueHkgLyBwYXR0ZXJuQm94U2l6ZTtcbiAgXG4gICAgI2lmZGVmIEFERF9IRUxQRVJTICBcbiAgICAgIHZlYzIgcGF0dGVybkhlbHBlckJveCA9IGdsX0ZyYWdDb29yZC54eSAvIHVfcmVzb2x1dGlvbi54eTtcbiAgICAgIHBhdHRlcm5IZWxwZXJCb3ggLT0gLjU7XG4gICAgICBwYXR0ZXJuSGVscGVyQm94ICo9IHBhdHRlcm5Xb3JsZFNjYWxlO1xuICAgICAgcGF0dGVybkhlbHBlckJveCArPSBib3hPcmlnaW4gKiAocGF0dGVybldvcmxkU2NhbGUgLSAxLik7ICBcbiAgICAjZW5kaWZcbiAgXG4gICAgdmVjMiBwYXR0ZXJuVVYgPSB1djtcbiAgICBwYXR0ZXJuVVYgKz0gdmVjMigtdV9vZmZzZXRYLCB1X29mZnNldFkpIC8gcGF0dGVybldvcmxkU2NhbGU7XG4gICAgcGF0dGVyblVWICs9IGJveE9yaWdpbjtcbiAgICBwYXR0ZXJuVVYgLT0gYm94T3JpZ2luIC8gcGF0dGVybldvcmxkU2NhbGU7XG4gICAgcGF0dGVyblVWICo9IHVfcmVzb2x1dGlvbi54eTtcbiAgICBwYXR0ZXJuVVYgLz0gdV9waXhlbFJhdGlvO1xuICAgIGlmICh1X2ZpdCA+IDAuKSB7XG4gICAgICBwYXR0ZXJuVVYgKj0gKHBhdHRlcm5Xb3JsZE5vRml0Qm94V2lkdGggLyBwYXR0ZXJuQm94U2l6ZS54KTtcbiAgICB9XG4gICAgcGF0dGVyblVWIC89IHVfc2NhbGU7XG4gICAgcGF0dGVyblVWID0gZ3JhcGhpY1JvdGF0aW9uICogcGF0dGVyblVWO1xuICAgIHBhdHRlcm5VViArPSBib3hPcmlnaW4gLyBwYXR0ZXJuV29ybGRTY2FsZTtcbiAgICBwYXR0ZXJuVVYgLT0gYm94T3JpZ2luO1xuICAgIHBhdHRlcm5VViArPSAuNTtcbiAgI2VuZGlmXG4gICAgXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuIFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gU2l6aW5nIGFwaSBmb3IgaW1hZ2UgZmlsdGVyc1xuICBcbiAgI2lmZGVmIFVTRV9JTUFHRV9TSVpJTkdcblxuICAgIHZlYzIgaW1hZ2VCb3hTaXplO1xuICAgIGlmICh1X2ZpdCA9PSAxLikgeyAvLyBjb250YWluXG4gICAgICBpbWFnZUJveFNpemUueCA9IG1pbihtYXhCb3hTaXplLnggLyB1X2ltYWdlQXNwZWN0UmF0aW8sIG1heEJveFNpemUueSkgKiB1X2ltYWdlQXNwZWN0UmF0aW87XG4gICAgfSBlbHNlIGlmICh1X2ZpdCA9PSAyLikgeyAvLyBjb3ZlclxuICAgICAgaW1hZ2VCb3hTaXplLnggPSBtYXgobWF4Qm94U2l6ZS54IC8gdV9pbWFnZUFzcGVjdFJhdGlvLCBtYXhCb3hTaXplLnkpICogdV9pbWFnZUFzcGVjdFJhdGlvO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbWFnZUJveFNpemUueCA9IG1pbigxMC4wLCAxMC4wIC8gdV9pbWFnZUFzcGVjdFJhdGlvICogdV9pbWFnZUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgaW1hZ2VCb3hTaXplLnkgPSBpbWFnZUJveFNpemUueCAvIHVfaW1hZ2VBc3BlY3RSYXRpbztcbiAgICB2ZWMyIGltYWdlQm94U2NhbGUgPSB1X3Jlc29sdXRpb24ueHkgLyBpbWFnZUJveFNpemU7XG5cbiAgICAjaWZkZWYgQUREX0hFTFBFUlNcbiAgICAgIHZlYzIgaW1hZ2VIZWxwZXJCb3ggPSB1djtcbiAgICAgIGltYWdlSGVscGVyQm94ICo9IGltYWdlQm94U2NhbGU7XG4gICAgICBpbWFnZUhlbHBlckJveCArPSBib3hPcmlnaW4gKiAoaW1hZ2VCb3hTY2FsZSAtIDEuKTtcbiAgICAjZW5kaWZcblxuICAgIHZlYzIgaW1hZ2VVViA9IHV2O1xuICAgIGltYWdlVVYgKj0gaW1hZ2VCb3hTY2FsZTtcbiAgICBpbWFnZVVWICs9IGJveE9yaWdpbiAqIChpbWFnZUJveFNjYWxlIC0gMS4pO1xuICAgIGltYWdlVVYgKz0gZ3JhcGhpY09mZnNldDtcbiAgICBpbWFnZVVWIC89IHVfc2NhbGU7XG4gICAgaW1hZ2VVVi54ICo9IHVfaW1hZ2VBc3BlY3RSYXRpbztcbiAgICBpbWFnZVVWID0gZ3JhcGhpY1JvdGF0aW9uICogaW1hZ2VVVjtcbiAgICBpbWFnZVVWLnggLz0gdV9pbWFnZUFzcGVjdFJhdGlvO1xuICAgIFxuICAgIGltYWdlVVYgKz0gLjU7XG4gICAgaW1hZ2VVVi55ID0gMS4gLSBpbWFnZVVWLnk7XG4gICNlbmRpZlxuYDtcbmNvbnN0IGRyYXdTaXppbmdIZWxwZXJzID0gYFxuICB2ZWMyIHdvcmxkQm94RGlzdCA9IGFicyhoZWxwZXJCb3gpO1xuICBmbG9hdCBib3hTdHJva2UgPSAoc3RlcChtYXgod29ybGRCb3hEaXN0LngsIHdvcmxkQm94RGlzdC55KSwgLjUpIC0gc3RlcChtYXgod29ybGRCb3hEaXN0LngsIHdvcmxkQm94RGlzdC55KSwgLjQ5NSkpO1xuICBjb2xvci5yZ2IgPSBtaXgoY29sb3IucmdiLCB2ZWMzKDEuLCAwLiwgMC4pLCBib3hTdHJva2UpO1xuICBvcGFjaXR5ICs9IGJveFN0cm9rZTtcblxuICB2ZWMyIGJveE9yaWdpbkNvcHkgPSB2ZWMyKC41IC0gdV9vcmlnaW5YLCB1X29yaWdpblkgLSAuNSk7XG4gIHZlYzIgYm94T3JpZ2luRGlzdCA9IGhlbHBlckJveCArIGJveE9yaWdpbkNvcHk7XG4gIGJveE9yaWdpbkRpc3QueCAqPSAoYm94U2l6ZS54IC8gYm94U2l6ZS55KTtcbiAgZmxvYXQgYm94T3JpZ2luUG9pbnQgPSAxLiAtIHNtb290aHN0ZXAoMC4sIC4wNSwgbGVuZ3RoKGJveE9yaWdpbkRpc3QpKTtcbiAgXG4gIHZlYzIgZ3JhcGhpY09yaWdpblBvaW50RGlzdCA9IGhlbHBlckJveCArIHZlYzIoLXVfb2Zmc2V0WCwgdV9vZmZzZXRZKTtcbiAgZ3JhcGhpY09yaWdpblBvaW50RGlzdC54ICo9IChib3hTaXplLnggLyBib3hTaXplLnkpO1xuICBmbG9hdCBncmFwaGljT3JpZ2luUG9pbnQgPSAxLiAtIHNtb290aHN0ZXAoMC4sIC4wNSwgbGVuZ3RoKGdyYXBoaWNPcmlnaW5Qb2ludERpc3QpKTtcbiAgXG4gIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIHZlYzMoMC4sIDEuLCAwLiksIGJveE9yaWdpblBvaW50KTtcbiAgb3BhY2l0eSArPSBib3hPcmlnaW5Qb2ludDtcbiAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgdmVjMygwLiwgMC4sIDEuKSwgZ3JhcGhpY09yaWdpblBvaW50KTtcbiAgb3BhY2l0eSArPSBncmFwaGljT3JpZ2luUG9pbnQ7XG5gO1xuY29uc3QgZGVmYXVsdE9iamVjdFNpemluZyA9IHtcbiAgZml0OiBcImNvbnRhaW5cIixcbiAgc2NhbGU6IDEsXG4gIHJvdGF0aW9uOiAwLFxuICBvZmZzZXRYOiAwLFxuICBvZmZzZXRZOiAwLFxuICBvcmlnaW5YOiAwLjUsXG4gIG9yaWdpblk6IDAuNSxcbiAgd29ybGRXaWR0aDogMCxcbiAgd29ybGRIZWlnaHQ6IDBcbn07XG5jb25zdCBkZWZhdWx0UGF0dGVyblNpemluZyA9IHtcbiAgZml0OiBcIm5vbmVcIixcbiAgc2NhbGU6IDEsXG4gIHJvdGF0aW9uOiAwLFxuICBvZmZzZXRYOiAwLFxuICBvZmZzZXRZOiAwLFxuICBvcmlnaW5YOiAwLjUsXG4gIG9yaWdpblk6IDAuNSxcbiAgd29ybGRXaWR0aDogMCxcbiAgd29ybGRIZWlnaHQ6IDBcbn07XG5jb25zdCBTaGFkZXJGaXRPcHRpb25zID0ge1xuICBub25lOiAwLFxuICBjb250YWluOiAxLFxuICBjb3ZlcjogMlxufTtcbmV4cG9ydCB7XG4gIFNoYWRlckZpdE9wdGlvbnMsXG4gIGRlZmF1bHRPYmplY3RTaXppbmcsXG4gIGRlZmF1bHRQYXR0ZXJuU2l6aW5nLFxuICBkcmF3U2l6aW5nSGVscGVycyxcbiAgc2l6aW5nRGVidWdWYXJpYWJsZXNEZWNsYXJhdGlvbixcbiAgc2l6aW5nVVYsXG4gIHNpemluZ1VuaWZvcm1zRGVjbGFyYXRpb24sXG4gIHNpemluZ1ZhcmlhYmxlc0RlY2xhcmF0aW9uXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhZGVyLXNpemluZy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/shader-utils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/shader-utils.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   colorBandingFix: () => (/* binding */ colorBandingFix),\n/* harmony export */   declarePI: () => (/* binding */ declarePI),\n/* harmony export */   fiberNoise: () => (/* binding */ fiberNoise),\n/* harmony export */   proceduralHash11: () => (/* binding */ proceduralHash11),\n/* harmony export */   proceduralHash21: () => (/* binding */ proceduralHash21),\n/* harmony export */   proceduralHash22: () => (/* binding */ proceduralHash22),\n/* harmony export */   rotation2: () => (/* binding */ rotation2),\n/* harmony export */   simplexNoise: () => (/* binding */ simplexNoise),\n/* harmony export */   textureRandomizerGB: () => (/* binding */ textureRandomizerGB),\n/* harmony export */   textureRandomizerR: () => (/* binding */ textureRandomizerR)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nconst declarePI = `\n#define TWO_PI 6.28318530718\n#define PI 3.14159265358979323846\n`;\nconst rotation2 = `\nvec2 rotate(vec2 uv, float th) {\n  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n`;\nconst proceduralHash11 = `\n  float hash11(float p) {\n    p = fract(p * 0.3183099) + 0.1;\n    p *= p + 19.19;\n    return fract(p * p);\n  }\n`;\nconst proceduralHash21 = `\n  float hash21(vec2 p) {\n    p = fract(p * vec2(0.3183099, 0.3678794)) + 0.1;\n    p += dot(p, p + 19.19);\n    return fract(p.x * p.y);\n  }\n`;\nconst proceduralHash22 = `\n  vec2 hash22(vec2 p) {\n    p = fract(p * vec2(0.3183099, 0.3678794)) + 0.1;\n    p += dot(p, p.yx + 19.19);\n    return fract(vec2(p.x * p.y, p.x + p.y));\n  }\n`;\nconst textureRandomizerR = `\n  float randomR(vec2 p) {\n    vec2 uv = floor(p) / 100. + .5;\n    return texture(u_noiseTexture, fract(uv)).r;\n  }\n`;\nconst textureRandomizerGB = `\n  vec2 randomGB(vec2 p) {\n    vec2 uv = floor(p) / 100. + .5;\n    return texture(u_noiseTexture, fract(uv)).gb;\n  }\n`;\nconst colorBandingFix = `\n  color += 1. / 256. * (fract(sin(dot(.014 * gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453123) - .5);\n`;\nconst simplexNoise = `\nvec3 permute(vec3 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n    -0.577350269189626, 0.024390243902439);\n  vec2 i = floor(v + dot(v, C.yy));\n  vec2 x0 = v - i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))\n    + i.x + vec3(0.0, i1.x, 1.0));\n  vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy),\n      dot(x12.zw, x12.zw)), 0.0);\n  m = m * m;\n  m = m * m;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n  vec3 g;\n  g.x = a0.x * x0.x + h.x * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n`;\nconst fiberNoise = `\nfloat fiberRandom(vec2 p) {\n  vec2 uv = floor(p) / 100.;\n  return texture(u_noiseTexture, fract(uv)).b;\n}\n\nfloat fiberValueNoise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n  float a = fiberRandom(i);\n  float b = fiberRandom(i + vec2(1.0, 0.0));\n  float c = fiberRandom(i + vec2(0.0, 1.0));\n  float d = fiberRandom(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  float x1 = mix(a, b, u.x);\n  float x2 = mix(c, d, u.x);\n  return mix(x1, x2, u.y);\n}\n\nfloat fiberNoiseFbm(in vec2 n, vec2 seedOffset) {\n  float total = 0.0, amplitude = 1.;\n  for (int i = 0; i < 4; i++) {\n    n = rotate(n, .7);\n    total += fiberValueNoise(n + seedOffset) * amplitude;\n    n *= 2.;\n    amplitude *= 0.6;\n  }\n  return total;\n}\n\nfloat fiberNoise(vec2 uv, vec2 seedOffset) {\n  float epsilon = 0.001;\n  float n1 = fiberNoiseFbm(uv + vec2(epsilon, 0.0), seedOffset);\n  float n2 = fiberNoiseFbm(uv - vec2(epsilon, 0.0), seedOffset);\n  float n3 = fiberNoiseFbm(uv + vec2(0.0, epsilon), seedOffset);\n  float n4 = fiberNoiseFbm(uv - vec2(0.0, epsilon), seedOffset);\n  return length(vec2(n1 - n2, n3 - n4)) / (2.0 * epsilon);\n}\n`;\n\n//# sourceMappingURL=shader-utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLXV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9AcGFwZXItZGVzaWduL3NoYWRlcnMvZGlzdC9zaGFkZXItdXRpbHMuanM/M2I0NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogICAgICAgICAgICAgICAgICAgIFBhcGVyIFNoYWRlcnMgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXBlci1kZXNpZ24vc2hhZGVycyAgICAgICAqXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cblxuY29uc3QgZGVjbGFyZVBJID0gYFxuI2RlZmluZSBUV09fUEkgNi4yODMxODUzMDcxOFxuI2RlZmluZSBQSSAzLjE0MTU5MjY1MzU4OTc5MzIzODQ2XG5gO1xuY29uc3Qgcm90YXRpb24yID0gYFxudmVjMiByb3RhdGUodmVjMiB1diwgZmxvYXQgdGgpIHtcbiAgcmV0dXJuIG1hdDIoY29zKHRoKSwgc2luKHRoKSwgLXNpbih0aCksIGNvcyh0aCkpICogdXY7XG59XG5gO1xuY29uc3QgcHJvY2VkdXJhbEhhc2gxMSA9IGBcbiAgZmxvYXQgaGFzaDExKGZsb2F0IHApIHtcbiAgICBwID0gZnJhY3QocCAqIDAuMzE4MzA5OSkgKyAwLjE7XG4gICAgcCAqPSBwICsgMTkuMTk7XG4gICAgcmV0dXJuIGZyYWN0KHAgKiBwKTtcbiAgfVxuYDtcbmNvbnN0IHByb2NlZHVyYWxIYXNoMjEgPSBgXG4gIGZsb2F0IGhhc2gyMSh2ZWMyIHApIHtcbiAgICBwID0gZnJhY3QocCAqIHZlYzIoMC4zMTgzMDk5LCAwLjM2Nzg3OTQpKSArIDAuMTtcbiAgICBwICs9IGRvdChwLCBwICsgMTkuMTkpO1xuICAgIHJldHVybiBmcmFjdChwLnggKiBwLnkpO1xuICB9XG5gO1xuY29uc3QgcHJvY2VkdXJhbEhhc2gyMiA9IGBcbiAgdmVjMiBoYXNoMjIodmVjMiBwKSB7XG4gICAgcCA9IGZyYWN0KHAgKiB2ZWMyKDAuMzE4MzA5OSwgMC4zNjc4Nzk0KSkgKyAwLjE7XG4gICAgcCArPSBkb3QocCwgcC55eCArIDE5LjE5KTtcbiAgICByZXR1cm4gZnJhY3QodmVjMihwLnggKiBwLnksIHAueCArIHAueSkpO1xuICB9XG5gO1xuY29uc3QgdGV4dHVyZVJhbmRvbWl6ZXJSID0gYFxuICBmbG9hdCByYW5kb21SKHZlYzIgcCkge1xuICAgIHZlYzIgdXYgPSBmbG9vcihwKSAvIDEwMC4gKyAuNTtcbiAgICByZXR1cm4gdGV4dHVyZSh1X25vaXNlVGV4dHVyZSwgZnJhY3QodXYpKS5yO1xuICB9XG5gO1xuY29uc3QgdGV4dHVyZVJhbmRvbWl6ZXJHQiA9IGBcbiAgdmVjMiByYW5kb21HQih2ZWMyIHApIHtcbiAgICB2ZWMyIHV2ID0gZmxvb3IocCkgLyAxMDAuICsgLjU7XG4gICAgcmV0dXJuIHRleHR1cmUodV9ub2lzZVRleHR1cmUsIGZyYWN0KHV2KSkuZ2I7XG4gIH1cbmA7XG5jb25zdCBjb2xvckJhbmRpbmdGaXggPSBgXG4gIGNvbG9yICs9IDEuIC8gMjU2LiAqIChmcmFjdChzaW4oZG90KC4wMTQgKiBnbF9GcmFnQ29vcmQueHksIHZlYzIoMTIuOTg5OCwgNzguMjMzKSkpICogNDM3NTguNTQ1MzEyMykgLSAuNSk7XG5gO1xuY29uc3Qgc2ltcGxleE5vaXNlID0gYFxudmVjMyBwZXJtdXRlKHZlYzMgeCkgeyByZXR1cm4gbW9kKCgoeCAqIDM0LjApICsgMS4wKSAqIHgsIDI4OS4wKTsgfVxuZmxvYXQgc25vaXNlKHZlYzIgdikge1xuICBjb25zdCB2ZWM0IEMgPSB2ZWM0KDAuMjExMzI0ODY1NDA1MTg3LCAwLjM2NjAyNTQwMzc4NDQzOSxcbiAgICAtMC41NzczNTAyNjkxODk2MjYsIDAuMDI0MzkwMjQzOTAyNDM5KTtcbiAgdmVjMiBpID0gZmxvb3IodiArIGRvdCh2LCBDLnl5KSk7XG4gIHZlYzIgeDAgPSB2IC0gaSArIGRvdChpLCBDLnh4KTtcbiAgdmVjMiBpMTtcbiAgaTEgPSAoeDAueCA+IHgwLnkpID8gdmVjMigxLjAsIDAuMCkgOiB2ZWMyKDAuMCwgMS4wKTtcbiAgdmVjNCB4MTIgPSB4MC54eXh5ICsgQy54eHp6O1xuICB4MTIueHkgLT0gaTE7XG4gIGkgPSBtb2QoaSwgMjg5LjApO1xuICB2ZWMzIHAgPSBwZXJtdXRlKHBlcm11dGUoaS55ICsgdmVjMygwLjAsIGkxLnksIDEuMCkpXG4gICAgKyBpLnggKyB2ZWMzKDAuMCwgaTEueCwgMS4wKSk7XG4gIHZlYzMgbSA9IG1heCgwLjUgLSB2ZWMzKGRvdCh4MCwgeDApLCBkb3QoeDEyLnh5LCB4MTIueHkpLFxuICAgICAgZG90KHgxMi56dywgeDEyLnp3KSksIDAuMCk7XG4gIG0gPSBtICogbTtcbiAgbSA9IG0gKiBtO1xuICB2ZWMzIHggPSAyLjAgKiBmcmFjdChwICogQy53d3cpIC0gMS4wO1xuICB2ZWMzIGggPSBhYnMoeCkgLSAwLjU7XG4gIHZlYzMgb3ggPSBmbG9vcih4ICsgMC41KTtcbiAgdmVjMyBhMCA9IHggLSBveDtcbiAgbSAqPSAxLjc5Mjg0MjkxNDAwMTU5IC0gMC44NTM3MzQ3MjA5NTMxNCAqIChhMCAqIGEwICsgaCAqIGgpO1xuICB2ZWMzIGc7XG4gIGcueCA9IGEwLnggKiB4MC54ICsgaC54ICogeDAueTtcbiAgZy55eiA9IGEwLnl6ICogeDEyLnh6ICsgaC55eiAqIHgxMi55dztcbiAgcmV0dXJuIDEzMC4wICogZG90KG0sIGcpO1xufVxuYDtcbmNvbnN0IGZpYmVyTm9pc2UgPSBgXG5mbG9hdCBmaWJlclJhbmRvbSh2ZWMyIHApIHtcbiAgdmVjMiB1diA9IGZsb29yKHApIC8gMTAwLjtcbiAgcmV0dXJuIHRleHR1cmUodV9ub2lzZVRleHR1cmUsIGZyYWN0KHV2KSkuYjtcbn1cblxuZmxvYXQgZmliZXJWYWx1ZU5vaXNlKHZlYzIgc3QpIHtcbiAgdmVjMiBpID0gZmxvb3Ioc3QpO1xuICB2ZWMyIGYgPSBmcmFjdChzdCk7XG4gIGZsb2F0IGEgPSBmaWJlclJhbmRvbShpKTtcbiAgZmxvYXQgYiA9IGZpYmVyUmFuZG9tKGkgKyB2ZWMyKDEuMCwgMC4wKSk7XG4gIGZsb2F0IGMgPSBmaWJlclJhbmRvbShpICsgdmVjMigwLjAsIDEuMCkpO1xuICBmbG9hdCBkID0gZmliZXJSYW5kb20oaSArIHZlYzIoMS4wLCAxLjApKTtcbiAgdmVjMiB1ID0gZiAqIGYgKiAoMy4wIC0gMi4wICogZik7XG4gIGZsb2F0IHgxID0gbWl4KGEsIGIsIHUueCk7XG4gIGZsb2F0IHgyID0gbWl4KGMsIGQsIHUueCk7XG4gIHJldHVybiBtaXgoeDEsIHgyLCB1LnkpO1xufVxuXG5mbG9hdCBmaWJlck5vaXNlRmJtKGluIHZlYzIgbiwgdmVjMiBzZWVkT2Zmc2V0KSB7XG4gIGZsb2F0IHRvdGFsID0gMC4wLCBhbXBsaXR1ZGUgPSAxLjtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBuID0gcm90YXRlKG4sIC43KTtcbiAgICB0b3RhbCArPSBmaWJlclZhbHVlTm9pc2UobiArIHNlZWRPZmZzZXQpICogYW1wbGl0dWRlO1xuICAgIG4gKj0gMi47XG4gICAgYW1wbGl0dWRlICo9IDAuNjtcbiAgfVxuICByZXR1cm4gdG90YWw7XG59XG5cbmZsb2F0IGZpYmVyTm9pc2UodmVjMiB1diwgdmVjMiBzZWVkT2Zmc2V0KSB7XG4gIGZsb2F0IGVwc2lsb24gPSAwLjAwMTtcbiAgZmxvYXQgbjEgPSBmaWJlck5vaXNlRmJtKHV2ICsgdmVjMihlcHNpbG9uLCAwLjApLCBzZWVkT2Zmc2V0KTtcbiAgZmxvYXQgbjIgPSBmaWJlck5vaXNlRmJtKHV2IC0gdmVjMihlcHNpbG9uLCAwLjApLCBzZWVkT2Zmc2V0KTtcbiAgZmxvYXQgbjMgPSBmaWJlck5vaXNlRmJtKHV2ICsgdmVjMigwLjAsIGVwc2lsb24pLCBzZWVkT2Zmc2V0KTtcbiAgZmxvYXQgbjQgPSBmaWJlck5vaXNlRmJtKHV2IC0gdmVjMigwLjAsIGVwc2lsb24pLCBzZWVkT2Zmc2V0KTtcbiAgcmV0dXJuIGxlbmd0aCh2ZWMyKG4xIC0gbjIsIG4zIC0gbjQpKSAvICgyLjAgKiBlcHNpbG9uKTtcbn1cbmA7XG5leHBvcnQge1xuICBjb2xvckJhbmRpbmdGaXgsXG4gIGRlY2xhcmVQSSxcbiAgZmliZXJOb2lzZSxcbiAgcHJvY2VkdXJhbEhhc2gxMSxcbiAgcHJvY2VkdXJhbEhhc2gyMSxcbiAgcHJvY2VkdXJhbEhhc2gyMixcbiAgcm90YXRpb24yLFxuICBzaW1wbGV4Tm9pc2UsXG4gIHRleHR1cmVSYW5kb21pemVyR0IsXG4gIHRleHR1cmVSYW5kb21pemVyUlxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYWRlci11dGlscy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/shader-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/shaders/mesh-gradient.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/shaders/mesh-gradient.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   meshGradientFragmentShader: () => (/* binding */ meshGradientFragmentShader),\n/* harmony export */   meshGradientMeta: () => (/* binding */ meshGradientMeta)\n/* harmony export */ });\n/* harmony import */ var _shader_sizing_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shader-sizing.js */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js\");\n/* harmony import */ var _shader_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shader-utils.js */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-utils.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\n\nconst meshGradientMeta = {\n  maxColorCount: 10\n};\nconst meshGradientFragmentShader = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\n\nuniform vec4 u_colors[${meshGradientMeta.maxColorCount}];\nuniform float u_colorsCount;\n\nuniform float u_distortion;\nuniform float u_swirl;\n\n${_shader_sizing_js__WEBPACK_IMPORTED_MODULE_0__.sizingVariablesDeclaration}\n\nout vec4 fragColor;\n\n${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.declarePI}\n${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotation2}\n\nvec2 getPosition(int i, float t) {\n  float a = float(i) * .37;\n  float b = .6 + mod(float(i), 3.) * .3;\n  float c = .8 + mod(float(i + 1), 4.) * 0.25;\n\n  float x = sin(t * b + a);\n  float y = cos(t * c + a * 1.5);\n\n  return .5 + .5 * vec2(x, y);\n}\n\nvoid main() {\n  vec2 shape_uv = v_objectUV;\n\n  shape_uv += .5;\n\n  float t = .5 * u_time;\n\n  float radius = smoothstep(0., 1., length(shape_uv - .5));\n  float center = 1. - radius;\n  for (float i = 1.; i <= 2.; i++) {\n    shape_uv.x += u_distortion * center / i * sin(t + i * .4 * smoothstep(.0, 1., shape_uv.y)) * cos(.2 * t + i * 2.4 * smoothstep(.0, 1., shape_uv.y));\n    shape_uv.y += u_distortion * center / i * cos(t + i * 2. * smoothstep(.0, 1., shape_uv.x));\n  }\n\n  vec2 uvRotated = shape_uv;\n  uvRotated -= vec2(.5);\n  float angle = 3. * u_swirl * radius;\n  uvRotated = rotate(uvRotated, -angle);\n  uvRotated += vec2(.5);\n\n  vec3 color = vec3(0.);\n  float opacity = 0.;\n  float totalWeight = 0.;\n\n  for (int i = 0; i < ${meshGradientMeta.maxColorCount}; i++) {\n    if (i >= int(u_colorsCount)) break;\n\n    vec2 pos = getPosition(i, t);\n    vec3 colorFraction = u_colors[i].rgb * u_colors[i].a;\n    float opacityFraction = u_colors[i].a;\n\n    float dist = length(uvRotated - pos);\n\n    dist = pow(dist, 3.5);\n    float weight = 1. / (dist + 1e-3);\n    color += colorFraction * weight;\n    opacity += opacityFraction * weight;\n    totalWeight += weight;\n  }\n\n  color /= totalWeight;\n  opacity /= totalWeight;\n\n  ${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.colorBandingFix}\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\n//# sourceMappingURL=mesh-gradient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVycy9tZXNoLWdyYWRpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUU7QUFDVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3QiwrQkFBK0I7QUFDdkQ7O0FBRUE7QUFDQTs7QUFFQSxFQUFFLHlFQUEwQjs7QUFFNUI7O0FBRUEsRUFBRSx1REFBUztBQUNYLEVBQUUsdURBQVM7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsTUFBTSxpQ0FBaUM7QUFDekQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUksNkRBQWU7O0FBRW5CO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVycy9tZXNoLWdyYWRpZW50LmpzPzExNDAiXSwic291cmNlc0NvbnRlbnQiOlsiLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqICAgICAgICAgICAgICAgICAgICBQYXBlciBTaGFkZXJzICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcGFwZXItZGVzaWduL3NoYWRlcnMgICAgICAgKlxuICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cbmltcG9ydCB7IHNpemluZ1ZhcmlhYmxlc0RlY2xhcmF0aW9uIH0gZnJvbSBcIi4uL3NoYWRlci1zaXppbmcuanNcIjtcbmltcG9ydCB7IGRlY2xhcmVQSSwgcm90YXRpb24yLCBjb2xvckJhbmRpbmdGaXggfSBmcm9tIFwiLi4vc2hhZGVyLXV0aWxzLmpzXCI7XG5jb25zdCBtZXNoR3JhZGllbnRNZXRhID0ge1xuICBtYXhDb2xvckNvdW50OiAxMFxufTtcbmNvbnN0IG1lc2hHcmFkaWVudEZyYWdtZW50U2hhZGVyID0gYCN2ZXJzaW9uIDMwMCBlc1xucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cbnVuaWZvcm0gZmxvYXQgdV90aW1lO1xuXG51bmlmb3JtIHZlYzQgdV9jb2xvcnNbJHttZXNoR3JhZGllbnRNZXRhLm1heENvbG9yQ291bnR9XTtcbnVuaWZvcm0gZmxvYXQgdV9jb2xvcnNDb3VudDtcblxudW5pZm9ybSBmbG9hdCB1X2Rpc3RvcnRpb247XG51bmlmb3JtIGZsb2F0IHVfc3dpcmw7XG5cbiR7c2l6aW5nVmFyaWFibGVzRGVjbGFyYXRpb259XG5cbm91dCB2ZWM0IGZyYWdDb2xvcjtcblxuJHtkZWNsYXJlUEl9XG4ke3JvdGF0aW9uMn1cblxudmVjMiBnZXRQb3NpdGlvbihpbnQgaSwgZmxvYXQgdCkge1xuICBmbG9hdCBhID0gZmxvYXQoaSkgKiAuMzc7XG4gIGZsb2F0IGIgPSAuNiArIG1vZChmbG9hdChpKSwgMy4pICogLjM7XG4gIGZsb2F0IGMgPSAuOCArIG1vZChmbG9hdChpICsgMSksIDQuKSAqIDAuMjU7XG5cbiAgZmxvYXQgeCA9IHNpbih0ICogYiArIGEpO1xuICBmbG9hdCB5ID0gY29zKHQgKiBjICsgYSAqIDEuNSk7XG5cbiAgcmV0dXJuIC41ICsgLjUgKiB2ZWMyKHgsIHkpO1xufVxuXG52b2lkIG1haW4oKSB7XG4gIHZlYzIgc2hhcGVfdXYgPSB2X29iamVjdFVWO1xuXG4gIHNoYXBlX3V2ICs9IC41O1xuXG4gIGZsb2F0IHQgPSAuNSAqIHVfdGltZTtcblxuICBmbG9hdCByYWRpdXMgPSBzbW9vdGhzdGVwKDAuLCAxLiwgbGVuZ3RoKHNoYXBlX3V2IC0gLjUpKTtcbiAgZmxvYXQgY2VudGVyID0gMS4gLSByYWRpdXM7XG4gIGZvciAoZmxvYXQgaSA9IDEuOyBpIDw9IDIuOyBpKyspIHtcbiAgICBzaGFwZV91di54ICs9IHVfZGlzdG9ydGlvbiAqIGNlbnRlciAvIGkgKiBzaW4odCArIGkgKiAuNCAqIHNtb290aHN0ZXAoLjAsIDEuLCBzaGFwZV91di55KSkgKiBjb3MoLjIgKiB0ICsgaSAqIDIuNCAqIHNtb290aHN0ZXAoLjAsIDEuLCBzaGFwZV91di55KSk7XG4gICAgc2hhcGVfdXYueSArPSB1X2Rpc3RvcnRpb24gKiBjZW50ZXIgLyBpICogY29zKHQgKyBpICogMi4gKiBzbW9vdGhzdGVwKC4wLCAxLiwgc2hhcGVfdXYueCkpO1xuICB9XG5cbiAgdmVjMiB1dlJvdGF0ZWQgPSBzaGFwZV91djtcbiAgdXZSb3RhdGVkIC09IHZlYzIoLjUpO1xuICBmbG9hdCBhbmdsZSA9IDMuICogdV9zd2lybCAqIHJhZGl1cztcbiAgdXZSb3RhdGVkID0gcm90YXRlKHV2Um90YXRlZCwgLWFuZ2xlKTtcbiAgdXZSb3RhdGVkICs9IHZlYzIoLjUpO1xuXG4gIHZlYzMgY29sb3IgPSB2ZWMzKDAuKTtcbiAgZmxvYXQgb3BhY2l0eSA9IDAuO1xuICBmbG9hdCB0b3RhbFdlaWdodCA9IDAuO1xuXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgJHttZXNoR3JhZGllbnRNZXRhLm1heENvbG9yQ291bnR9OyBpKyspIHtcbiAgICBpZiAoaSA+PSBpbnQodV9jb2xvcnNDb3VudCkpIGJyZWFrO1xuXG4gICAgdmVjMiBwb3MgPSBnZXRQb3NpdGlvbihpLCB0KTtcbiAgICB2ZWMzIGNvbG9yRnJhY3Rpb24gPSB1X2NvbG9yc1tpXS5yZ2IgKiB1X2NvbG9yc1tpXS5hO1xuICAgIGZsb2F0IG9wYWNpdHlGcmFjdGlvbiA9IHVfY29sb3JzW2ldLmE7XG5cbiAgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKHV2Um90YXRlZCAtIHBvcyk7XG5cbiAgICBkaXN0ID0gcG93KGRpc3QsIDMuNSk7XG4gICAgZmxvYXQgd2VpZ2h0ID0gMS4gLyAoZGlzdCArIDFlLTMpO1xuICAgIGNvbG9yICs9IGNvbG9yRnJhY3Rpb24gKiB3ZWlnaHQ7XG4gICAgb3BhY2l0eSArPSBvcGFjaXR5RnJhY3Rpb24gKiB3ZWlnaHQ7XG4gICAgdG90YWxXZWlnaHQgKz0gd2VpZ2h0O1xuICB9XG5cbiAgY29sb3IgLz0gdG90YWxXZWlnaHQ7XG4gIG9wYWNpdHkgLz0gdG90YWxXZWlnaHQ7XG5cbiAgJHtjb2xvckJhbmRpbmdGaXh9XG5cbiAgZnJhZ0NvbG9yID0gdmVjNChjb2xvciwgb3BhY2l0eSk7XG59XG5gO1xuZXhwb3J0IHtcbiAgbWVzaEdyYWRpZW50RnJhZ21lbnRTaGFkZXIsXG4gIG1lc2hHcmFkaWVudE1ldGFcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXNoLWdyYWRpZW50LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/shaders/mesh-gradient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/vertex-shader.js":
/*!******************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/vertex-shader.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   vertexShaderSource: () => (/* binding */ vertexShaderSource)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nconst vertexShaderSource = `#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec4 a_position;\n\nuniform vec2 u_resolution;\nuniform float u_pixelRatio;\nuniform float u_imageAspectRatio;\n\nuniform float u_originX;\nuniform float u_originY;\nuniform float u_worldWidth;\nuniform float u_worldHeight;\nuniform float u_fit;\n\nuniform float u_scale;\nuniform float u_rotation;\nuniform float u_offsetX;\nuniform float u_offsetY;\n\nuniform float u_pxSize;\n\nout vec2 v_objectUV;\nout vec2 v_objectBoxSize;\nout vec2 v_objectHelperBox;\n\nout vec2 v_responsiveUV;\nout vec2 v_responsiveBoxSize;\nout vec2 v_responsiveHelperBox;\nout vec2 v_responsiveBoxGivenSize;\n\nout vec2 v_patternUV;\nout vec2 v_patternBoxSize;\nout vec2 v_patternHelperBox;\n\nout vec2 v_imageUV;\n\n// #define ADD_HELPERS\n\nvec3 getBoxSize(float boxRatio, vec2 givenBoxSize, vec2 maxBoxSize) {\n  vec2 box = vec2(0.);\n  // fit = none\n  box.x = boxRatio * min(givenBoxSize.x / boxRatio, givenBoxSize.y);\n  float noFitBoxWidth = box.x;\n  if (u_fit == 1.) { // fit = contain\n    box.x = boxRatio * min(maxBoxSize[0] / boxRatio, maxBoxSize[1]);\n  } else if (u_fit == 2.) { // fit = cover\n    box.x = boxRatio * max(maxBoxSize[0] / boxRatio, maxBoxSize[1]);\n  }\n  box.y = box.x / boxRatio;\n  return vec3(box, noFitBoxWidth);\n}\n\nvoid main() {\n  gl_Position = a_position;\n\n  vec2 uv = gl_Position.xy * .5;\n  vec2 boxOrigin = vec2(.5 - u_originX, u_originY - .5);\n  vec2 givenBoxSize = vec2(u_worldWidth, u_worldHeight);\n  givenBoxSize = max(givenBoxSize, vec2(1.)) * u_pixelRatio;\n  vec2 maxBoxSize = vec2(max(u_resolution.x, givenBoxSize.x), max(u_resolution.y, givenBoxSize.y));\n  float r = u_rotation * 3.14159265358979323846 / 180.;\n  mat2 graphicRotation = mat2(cos(r), sin(r), -sin(r), cos(r));\n  vec2 graphicOffset = vec2(-u_offsetX, u_offsetY);\n\n\n  // ===================================================\n  // Sizing api for graphic objects with fixed ratio\n  // (currently supports only ratio = 1)\n\n  float fixedRatio = 1.;\n  vec2 fixedRatioBoxGivenSize = vec2(\n  (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n  (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n\n  v_objectBoxSize = getBoxSize(fixedRatio, fixedRatioBoxGivenSize, maxBoxSize).xy;\n  vec2 objectWorldScale = u_resolution.xy / v_objectBoxSize;\n\n  #ifdef ADD_HELPERS\n  v_objectHelperBox = uv;\n  v_objectHelperBox *= objectWorldScale;\n  v_objectHelperBox += boxOrigin * (objectWorldScale - 1.);\n  #endif\n\n  v_objectUV = uv;\n  v_objectUV *= objectWorldScale;\n  v_objectUV += boxOrigin * (objectWorldScale - 1.);\n  v_objectUV += graphicOffset;\n  v_objectUV /= u_scale;\n  v_objectUV = graphicRotation * v_objectUV;\n\n\n  // ===================================================\n\n\n  // ===================================================\n  // Sizing api for graphic objects with either givenBoxSize ratio or canvas ratio.\n  // Full-screen mode available with u_worldWidth = u_worldHeight = 0\n\n  v_responsiveBoxGivenSize = vec2(\n  (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n  (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n  float responsiveRatio = v_responsiveBoxGivenSize.x / v_responsiveBoxGivenSize.y;\n  v_responsiveBoxSize = getBoxSize(responsiveRatio, v_responsiveBoxGivenSize, maxBoxSize).xy;\n  vec2 responsiveBoxScale = u_resolution.xy / v_responsiveBoxSize;\n\n  #ifdef ADD_HELPERS\n  v_responsiveHelperBox = uv;\n  v_responsiveHelperBox *= responsiveBoxScale;\n  v_responsiveHelperBox += boxOrigin * (responsiveBoxScale - 1.);\n  #endif\n\n  v_responsiveUV = uv;\n  v_responsiveUV *= responsiveBoxScale;\n  v_responsiveUV += boxOrigin * (responsiveBoxScale - 1.);\n  v_responsiveUV += graphicOffset;\n  v_responsiveUV /= u_scale;\n  v_responsiveUV.x *= responsiveRatio;\n  v_responsiveUV = graphicRotation * v_responsiveUV;\n  v_responsiveUV.x /= responsiveRatio;\n\n  // ===================================================\n\n\n  // ===================================================\n  // Sizing api for patterns\n  // (treating graphics as a image u_worldWidth x u_worldHeight size)\n\n  float patternBoxRatio = givenBoxSize.x / givenBoxSize.y;\n  vec2 patternBoxGivenSize = vec2(\n  (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n  (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n  patternBoxRatio = patternBoxGivenSize.x / patternBoxGivenSize.y;\n\n  vec3 boxSizeData = getBoxSize(patternBoxRatio, patternBoxGivenSize, maxBoxSize);\n  v_patternBoxSize = boxSizeData.xy;\n  float patternBoxNoFitBoxWidth = boxSizeData.z;\n  vec2 patternBoxScale = u_resolution.xy / v_patternBoxSize;\n\n  #ifdef ADD_HELPERS\n  v_patternHelperBox = uv;\n  v_patternHelperBox *= patternBoxScale;\n  v_patternHelperBox += boxOrigin * (patternBoxScale - 1.);\n  #endif\n\n  v_patternUV = uv;\n  v_patternUV += graphicOffset / patternBoxScale;\n  v_patternUV += boxOrigin;\n  v_patternUV -= boxOrigin / patternBoxScale;\n  v_patternUV *= u_resolution.xy;\n  v_patternUV /= u_pixelRatio;\n  if (u_fit > 0.) {\n    v_patternUV *= (patternBoxNoFitBoxWidth / v_patternBoxSize.x);\n  }\n  v_patternUV /= u_scale;\n  v_patternUV = graphicRotation * v_patternUV;\n  v_patternUV += boxOrigin / patternBoxScale;\n  v_patternUV -= boxOrigin;\n  // x100 is a default multiplier between vertex and fragmant shaders\n  // we use it to avoid UV presision issues\n  v_patternUV *= .01;\n\n  // ===================================================\n\n\n  // ===================================================\n  // Sizing api for images\n\n  vec2 imageBoxSize;\n  if (u_fit == 1.) { // contain\n    imageBoxSize.x = min(maxBoxSize.x / u_imageAspectRatio, maxBoxSize.y) * u_imageAspectRatio;\n  } else if (u_fit == 2.) { // cover\n    imageBoxSize.x = max(maxBoxSize.x / u_imageAspectRatio, maxBoxSize.y) * u_imageAspectRatio;\n  } else {\n    imageBoxSize.x = min(10.0, 10.0 / u_imageAspectRatio * u_imageAspectRatio);\n  }\n  imageBoxSize.y = imageBoxSize.x / u_imageAspectRatio;\n  vec2 imageBoxScale = u_resolution.xy / imageBoxSize;\n\n  #ifdef ADD_HELPERS\n  vec2 imageHelperBox = uv;\n  imageHelperBox *= imageBoxScale;\n  imageHelperBox += boxOrigin * (imageBoxScale - 1.);\n  #endif\n\n  v_imageUV = uv;\n  v_imageUV *= imageBoxScale;\n  v_imageUV += boxOrigin * (imageBoxScale - 1.);\n  v_imageUV += graphicOffset;\n  v_imageUV /= u_scale;\n  v_imageUV.x *= u_imageAspectRatio;\n  v_imageUV = graphicRotation * v_imageUV;\n  v_imageUV.x /= u_imageAspectRatio;\n\n  v_imageUV += .5;\n  v_imageUV.y = 1. - v_imageUV.y;\n\n  // ===================================================\n\n}`;\n\n//# sourceMappingURL=vertex-shader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvdmVydGV4LXNoYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLElBQUksd0JBQXdCO0FBQzVCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUM7QUFHQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BwYXBlci1kZXNpZ24vc2hhZGVycy9kaXN0L3ZlcnRleC1zaGFkZXIuanM/ZDBkOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogICAgICAgICAgICAgICAgICAgIFBhcGVyIFNoYWRlcnMgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXBlci1kZXNpZ24vc2hhZGVycyAgICAgICAqXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cblxuY29uc3QgdmVydGV4U2hhZGVyU291cmNlID0gYCN2ZXJzaW9uIDMwMCBlc1xucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cbmxheW91dChsb2NhdGlvbiA9IDApIGluIHZlYzQgYV9wb3NpdGlvbjtcblxudW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcbnVuaWZvcm0gZmxvYXQgdV9waXhlbFJhdGlvO1xudW5pZm9ybSBmbG9hdCB1X2ltYWdlQXNwZWN0UmF0aW87XG5cbnVuaWZvcm0gZmxvYXQgdV9vcmlnaW5YO1xudW5pZm9ybSBmbG9hdCB1X29yaWdpblk7XG51bmlmb3JtIGZsb2F0IHVfd29ybGRXaWR0aDtcbnVuaWZvcm0gZmxvYXQgdV93b3JsZEhlaWdodDtcbnVuaWZvcm0gZmxvYXQgdV9maXQ7XG5cbnVuaWZvcm0gZmxvYXQgdV9zY2FsZTtcbnVuaWZvcm0gZmxvYXQgdV9yb3RhdGlvbjtcbnVuaWZvcm0gZmxvYXQgdV9vZmZzZXRYO1xudW5pZm9ybSBmbG9hdCB1X29mZnNldFk7XG5cbnVuaWZvcm0gZmxvYXQgdV9weFNpemU7XG5cbm91dCB2ZWMyIHZfb2JqZWN0VVY7XG5vdXQgdmVjMiB2X29iamVjdEJveFNpemU7XG5vdXQgdmVjMiB2X29iamVjdEhlbHBlckJveDtcblxub3V0IHZlYzIgdl9yZXNwb25zaXZlVVY7XG5vdXQgdmVjMiB2X3Jlc3BvbnNpdmVCb3hTaXplO1xub3V0IHZlYzIgdl9yZXNwb25zaXZlSGVscGVyQm94O1xub3V0IHZlYzIgdl9yZXNwb25zaXZlQm94R2l2ZW5TaXplO1xuXG5vdXQgdmVjMiB2X3BhdHRlcm5VVjtcbm91dCB2ZWMyIHZfcGF0dGVybkJveFNpemU7XG5vdXQgdmVjMiB2X3BhdHRlcm5IZWxwZXJCb3g7XG5cbm91dCB2ZWMyIHZfaW1hZ2VVVjtcblxuLy8gI2RlZmluZSBBRERfSEVMUEVSU1xuXG52ZWMzIGdldEJveFNpemUoZmxvYXQgYm94UmF0aW8sIHZlYzIgZ2l2ZW5Cb3hTaXplLCB2ZWMyIG1heEJveFNpemUpIHtcbiAgdmVjMiBib3ggPSB2ZWMyKDAuKTtcbiAgLy8gZml0ID0gbm9uZVxuICBib3gueCA9IGJveFJhdGlvICogbWluKGdpdmVuQm94U2l6ZS54IC8gYm94UmF0aW8sIGdpdmVuQm94U2l6ZS55KTtcbiAgZmxvYXQgbm9GaXRCb3hXaWR0aCA9IGJveC54O1xuICBpZiAodV9maXQgPT0gMS4pIHsgLy8gZml0ID0gY29udGFpblxuICAgIGJveC54ID0gYm94UmF0aW8gKiBtaW4obWF4Qm94U2l6ZVswXSAvIGJveFJhdGlvLCBtYXhCb3hTaXplWzFdKTtcbiAgfSBlbHNlIGlmICh1X2ZpdCA9PSAyLikgeyAvLyBmaXQgPSBjb3ZlclxuICAgIGJveC54ID0gYm94UmF0aW8gKiBtYXgobWF4Qm94U2l6ZVswXSAvIGJveFJhdGlvLCBtYXhCb3hTaXplWzFdKTtcbiAgfVxuICBib3gueSA9IGJveC54IC8gYm94UmF0aW87XG4gIHJldHVybiB2ZWMzKGJveCwgbm9GaXRCb3hXaWR0aCk7XG59XG5cbnZvaWQgbWFpbigpIHtcbiAgZ2xfUG9zaXRpb24gPSBhX3Bvc2l0aW9uO1xuXG4gIHZlYzIgdXYgPSBnbF9Qb3NpdGlvbi54eSAqIC41O1xuICB2ZWMyIGJveE9yaWdpbiA9IHZlYzIoLjUgLSB1X29yaWdpblgsIHVfb3JpZ2luWSAtIC41KTtcbiAgdmVjMiBnaXZlbkJveFNpemUgPSB2ZWMyKHVfd29ybGRXaWR0aCwgdV93b3JsZEhlaWdodCk7XG4gIGdpdmVuQm94U2l6ZSA9IG1heChnaXZlbkJveFNpemUsIHZlYzIoMS4pKSAqIHVfcGl4ZWxSYXRpbztcbiAgdmVjMiBtYXhCb3hTaXplID0gdmVjMihtYXgodV9yZXNvbHV0aW9uLngsIGdpdmVuQm94U2l6ZS54KSwgbWF4KHVfcmVzb2x1dGlvbi55LCBnaXZlbkJveFNpemUueSkpO1xuICBmbG9hdCByID0gdV9yb3RhdGlvbiAqIDMuMTQxNTkyNjUzNTg5NzkzMjM4NDYgLyAxODAuO1xuICBtYXQyIGdyYXBoaWNSb3RhdGlvbiA9IG1hdDIoY29zKHIpLCBzaW4ociksIC1zaW4ociksIGNvcyhyKSk7XG4gIHZlYzIgZ3JhcGhpY09mZnNldCA9IHZlYzIoLXVfb2Zmc2V0WCwgdV9vZmZzZXRZKTtcblxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBTaXppbmcgYXBpIGZvciBncmFwaGljIG9iamVjdHMgd2l0aCBmaXhlZCByYXRpb1xuICAvLyAoY3VycmVudGx5IHN1cHBvcnRzIG9ubHkgcmF0aW8gPSAxKVxuXG4gIGZsb2F0IGZpeGVkUmF0aW8gPSAxLjtcbiAgdmVjMiBmaXhlZFJhdGlvQm94R2l2ZW5TaXplID0gdmVjMihcbiAgKHVfd29ybGRXaWR0aCA9PSAwLikgPyB1X3Jlc29sdXRpb24ueCA6IGdpdmVuQm94U2l6ZS54LFxuICAodV93b3JsZEhlaWdodCA9PSAwLikgPyB1X3Jlc29sdXRpb24ueSA6IGdpdmVuQm94U2l6ZS55XG4gICk7XG5cbiAgdl9vYmplY3RCb3hTaXplID0gZ2V0Qm94U2l6ZShmaXhlZFJhdGlvLCBmaXhlZFJhdGlvQm94R2l2ZW5TaXplLCBtYXhCb3hTaXplKS54eTtcbiAgdmVjMiBvYmplY3RXb3JsZFNjYWxlID0gdV9yZXNvbHV0aW9uLnh5IC8gdl9vYmplY3RCb3hTaXplO1xuXG4gICNpZmRlZiBBRERfSEVMUEVSU1xuICB2X29iamVjdEhlbHBlckJveCA9IHV2O1xuICB2X29iamVjdEhlbHBlckJveCAqPSBvYmplY3RXb3JsZFNjYWxlO1xuICB2X29iamVjdEhlbHBlckJveCArPSBib3hPcmlnaW4gKiAob2JqZWN0V29ybGRTY2FsZSAtIDEuKTtcbiAgI2VuZGlmXG5cbiAgdl9vYmplY3RVViA9IHV2O1xuICB2X29iamVjdFVWICo9IG9iamVjdFdvcmxkU2NhbGU7XG4gIHZfb2JqZWN0VVYgKz0gYm94T3JpZ2luICogKG9iamVjdFdvcmxkU2NhbGUgLSAxLik7XG4gIHZfb2JqZWN0VVYgKz0gZ3JhcGhpY09mZnNldDtcbiAgdl9vYmplY3RVViAvPSB1X3NjYWxlO1xuICB2X29iamVjdFVWID0gZ3JhcGhpY1JvdGF0aW9uICogdl9vYmplY3RVVjtcblxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFNpemluZyBhcGkgZm9yIGdyYXBoaWMgb2JqZWN0cyB3aXRoIGVpdGhlciBnaXZlbkJveFNpemUgcmF0aW8gb3IgY2FudmFzIHJhdGlvLlxuICAvLyBGdWxsLXNjcmVlbiBtb2RlIGF2YWlsYWJsZSB3aXRoIHVfd29ybGRXaWR0aCA9IHVfd29ybGRIZWlnaHQgPSAwXG5cbiAgdl9yZXNwb25zaXZlQm94R2l2ZW5TaXplID0gdmVjMihcbiAgKHVfd29ybGRXaWR0aCA9PSAwLikgPyB1X3Jlc29sdXRpb24ueCA6IGdpdmVuQm94U2l6ZS54LFxuICAodV93b3JsZEhlaWdodCA9PSAwLikgPyB1X3Jlc29sdXRpb24ueSA6IGdpdmVuQm94U2l6ZS55XG4gICk7XG4gIGZsb2F0IHJlc3BvbnNpdmVSYXRpbyA9IHZfcmVzcG9uc2l2ZUJveEdpdmVuU2l6ZS54IC8gdl9yZXNwb25zaXZlQm94R2l2ZW5TaXplLnk7XG4gIHZfcmVzcG9uc2l2ZUJveFNpemUgPSBnZXRCb3hTaXplKHJlc3BvbnNpdmVSYXRpbywgdl9yZXNwb25zaXZlQm94R2l2ZW5TaXplLCBtYXhCb3hTaXplKS54eTtcbiAgdmVjMiByZXNwb25zaXZlQm94U2NhbGUgPSB1X3Jlc29sdXRpb24ueHkgLyB2X3Jlc3BvbnNpdmVCb3hTaXplO1xuXG4gICNpZmRlZiBBRERfSEVMUEVSU1xuICB2X3Jlc3BvbnNpdmVIZWxwZXJCb3ggPSB1djtcbiAgdl9yZXNwb25zaXZlSGVscGVyQm94ICo9IHJlc3BvbnNpdmVCb3hTY2FsZTtcbiAgdl9yZXNwb25zaXZlSGVscGVyQm94ICs9IGJveE9yaWdpbiAqIChyZXNwb25zaXZlQm94U2NhbGUgLSAxLik7XG4gICNlbmRpZlxuXG4gIHZfcmVzcG9uc2l2ZVVWID0gdXY7XG4gIHZfcmVzcG9uc2l2ZVVWICo9IHJlc3BvbnNpdmVCb3hTY2FsZTtcbiAgdl9yZXNwb25zaXZlVVYgKz0gYm94T3JpZ2luICogKHJlc3BvbnNpdmVCb3hTY2FsZSAtIDEuKTtcbiAgdl9yZXNwb25zaXZlVVYgKz0gZ3JhcGhpY09mZnNldDtcbiAgdl9yZXNwb25zaXZlVVYgLz0gdV9zY2FsZTtcbiAgdl9yZXNwb25zaXZlVVYueCAqPSByZXNwb25zaXZlUmF0aW87XG4gIHZfcmVzcG9uc2l2ZVVWID0gZ3JhcGhpY1JvdGF0aW9uICogdl9yZXNwb25zaXZlVVY7XG4gIHZfcmVzcG9uc2l2ZVVWLnggLz0gcmVzcG9uc2l2ZVJhdGlvO1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFNpemluZyBhcGkgZm9yIHBhdHRlcm5zXG4gIC8vICh0cmVhdGluZyBncmFwaGljcyBhcyBhIGltYWdlIHVfd29ybGRXaWR0aCB4IHVfd29ybGRIZWlnaHQgc2l6ZSlcblxuICBmbG9hdCBwYXR0ZXJuQm94UmF0aW8gPSBnaXZlbkJveFNpemUueCAvIGdpdmVuQm94U2l6ZS55O1xuICB2ZWMyIHBhdHRlcm5Cb3hHaXZlblNpemUgPSB2ZWMyKFxuICAodV93b3JsZFdpZHRoID09IDAuKSA/IHVfcmVzb2x1dGlvbi54IDogZ2l2ZW5Cb3hTaXplLngsXG4gICh1X3dvcmxkSGVpZ2h0ID09IDAuKSA/IHVfcmVzb2x1dGlvbi55IDogZ2l2ZW5Cb3hTaXplLnlcbiAgKTtcbiAgcGF0dGVybkJveFJhdGlvID0gcGF0dGVybkJveEdpdmVuU2l6ZS54IC8gcGF0dGVybkJveEdpdmVuU2l6ZS55O1xuXG4gIHZlYzMgYm94U2l6ZURhdGEgPSBnZXRCb3hTaXplKHBhdHRlcm5Cb3hSYXRpbywgcGF0dGVybkJveEdpdmVuU2l6ZSwgbWF4Qm94U2l6ZSk7XG4gIHZfcGF0dGVybkJveFNpemUgPSBib3hTaXplRGF0YS54eTtcbiAgZmxvYXQgcGF0dGVybkJveE5vRml0Qm94V2lkdGggPSBib3hTaXplRGF0YS56O1xuICB2ZWMyIHBhdHRlcm5Cb3hTY2FsZSA9IHVfcmVzb2x1dGlvbi54eSAvIHZfcGF0dGVybkJveFNpemU7XG5cbiAgI2lmZGVmIEFERF9IRUxQRVJTXG4gIHZfcGF0dGVybkhlbHBlckJveCA9IHV2O1xuICB2X3BhdHRlcm5IZWxwZXJCb3ggKj0gcGF0dGVybkJveFNjYWxlO1xuICB2X3BhdHRlcm5IZWxwZXJCb3ggKz0gYm94T3JpZ2luICogKHBhdHRlcm5Cb3hTY2FsZSAtIDEuKTtcbiAgI2VuZGlmXG5cbiAgdl9wYXR0ZXJuVVYgPSB1djtcbiAgdl9wYXR0ZXJuVVYgKz0gZ3JhcGhpY09mZnNldCAvIHBhdHRlcm5Cb3hTY2FsZTtcbiAgdl9wYXR0ZXJuVVYgKz0gYm94T3JpZ2luO1xuICB2X3BhdHRlcm5VViAtPSBib3hPcmlnaW4gLyBwYXR0ZXJuQm94U2NhbGU7XG4gIHZfcGF0dGVyblVWICo9IHVfcmVzb2x1dGlvbi54eTtcbiAgdl9wYXR0ZXJuVVYgLz0gdV9waXhlbFJhdGlvO1xuICBpZiAodV9maXQgPiAwLikge1xuICAgIHZfcGF0dGVyblVWICo9IChwYXR0ZXJuQm94Tm9GaXRCb3hXaWR0aCAvIHZfcGF0dGVybkJveFNpemUueCk7XG4gIH1cbiAgdl9wYXR0ZXJuVVYgLz0gdV9zY2FsZTtcbiAgdl9wYXR0ZXJuVVYgPSBncmFwaGljUm90YXRpb24gKiB2X3BhdHRlcm5VVjtcbiAgdl9wYXR0ZXJuVVYgKz0gYm94T3JpZ2luIC8gcGF0dGVybkJveFNjYWxlO1xuICB2X3BhdHRlcm5VViAtPSBib3hPcmlnaW47XG4gIC8vIHgxMDAgaXMgYSBkZWZhdWx0IG11bHRpcGxpZXIgYmV0d2VlbiB2ZXJ0ZXggYW5kIGZyYWdtYW50IHNoYWRlcnNcbiAgLy8gd2UgdXNlIGl0IHRvIGF2b2lkIFVWIHByZXNpc2lvbiBpc3N1ZXNcbiAgdl9wYXR0ZXJuVVYgKj0gLjAxO1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFNpemluZyBhcGkgZm9yIGltYWdlc1xuXG4gIHZlYzIgaW1hZ2VCb3hTaXplO1xuICBpZiAodV9maXQgPT0gMS4pIHsgLy8gY29udGFpblxuICAgIGltYWdlQm94U2l6ZS54ID0gbWluKG1heEJveFNpemUueCAvIHVfaW1hZ2VBc3BlY3RSYXRpbywgbWF4Qm94U2l6ZS55KSAqIHVfaW1hZ2VBc3BlY3RSYXRpbztcbiAgfSBlbHNlIGlmICh1X2ZpdCA9PSAyLikgeyAvLyBjb3ZlclxuICAgIGltYWdlQm94U2l6ZS54ID0gbWF4KG1heEJveFNpemUueCAvIHVfaW1hZ2VBc3BlY3RSYXRpbywgbWF4Qm94U2l6ZS55KSAqIHVfaW1hZ2VBc3BlY3RSYXRpbztcbiAgfSBlbHNlIHtcbiAgICBpbWFnZUJveFNpemUueCA9IG1pbigxMC4wLCAxMC4wIC8gdV9pbWFnZUFzcGVjdFJhdGlvICogdV9pbWFnZUFzcGVjdFJhdGlvKTtcbiAgfVxuICBpbWFnZUJveFNpemUueSA9IGltYWdlQm94U2l6ZS54IC8gdV9pbWFnZUFzcGVjdFJhdGlvO1xuICB2ZWMyIGltYWdlQm94U2NhbGUgPSB1X3Jlc29sdXRpb24ueHkgLyBpbWFnZUJveFNpemU7XG5cbiAgI2lmZGVmIEFERF9IRUxQRVJTXG4gIHZlYzIgaW1hZ2VIZWxwZXJCb3ggPSB1djtcbiAgaW1hZ2VIZWxwZXJCb3ggKj0gaW1hZ2VCb3hTY2FsZTtcbiAgaW1hZ2VIZWxwZXJCb3ggKz0gYm94T3JpZ2luICogKGltYWdlQm94U2NhbGUgLSAxLik7XG4gICNlbmRpZlxuXG4gIHZfaW1hZ2VVViA9IHV2O1xuICB2X2ltYWdlVVYgKj0gaW1hZ2VCb3hTY2FsZTtcbiAgdl9pbWFnZVVWICs9IGJveE9yaWdpbiAqIChpbWFnZUJveFNjYWxlIC0gMS4pO1xuICB2X2ltYWdlVVYgKz0gZ3JhcGhpY09mZnNldDtcbiAgdl9pbWFnZVVWIC89IHVfc2NhbGU7XG4gIHZfaW1hZ2VVVi54ICo9IHVfaW1hZ2VBc3BlY3RSYXRpbztcbiAgdl9pbWFnZVVWID0gZ3JhcGhpY1JvdGF0aW9uICogdl9pbWFnZVVWO1xuICB2X2ltYWdlVVYueCAvPSB1X2ltYWdlQXNwZWN0UmF0aW87XG5cbiAgdl9pbWFnZVVWICs9IC41O1xuICB2X2ltYWdlVVYueSA9IDEuIC0gdl9pbWFnZVVWLnk7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbn1gO1xuZXhwb3J0IHtcbiAgdmVydGV4U2hhZGVyU291cmNlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVydGV4LXNoYWRlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/vertex-shader.js\n");

/***/ })

};
;